{"version":3,"file":"pixi-filters.js","sources":["../src/adjustment/AdjustmentFilter.ts","../src/kawase-blur/KawaseBlurFilter.ts","../src/advanced-bloom/ExtractBrightnessFilter.ts","../src/advanced-bloom/AdvancedBloomFilter.ts","../src/ascii/AsciiFilter.ts","../src/backdrop-blur/BackdropBlurFilter.ts","../src/bevel/BevelFilter.ts","../src/bloom/BloomFilter.ts","../src/bulge-pinch/BulgePinchFilter.ts","../node_modules/gradient-parser/build/node.js","../src/color-gradient/CssGradientParser.ts","../src/color-gradient/ColorGradientFilter.ts","../src/color-map/ColorMapFilter.ts","../src/color-overlay/ColorOverlayFilter.ts","../src/color-replace/ColorReplaceFilter.ts","../src/convolution/ConvolutionFilter.ts","../src/cross-hatch/CrossHatchFilter.ts","../src/crt/CRTFilter.ts","../src/dot/DotFilter.ts","../src/drop-shadow/DropShadowFilter.ts","../src/emboss/EmbossFilter.ts","../src/glitch/GlitchFilter.ts","../src/glow/GlowFilter.ts","../src/godray/GodrayFilter.ts","../src/grayscale/GrayscaleFilter.ts","../src/hsl-adjustment/HslAdjustmentFilter.ts","../src/motion-blur/MotionBlurFilter.ts","../src/multi-color-replace/MultiColorReplaceFilter.ts","../src/old-film/OldFilmFilter.ts","../src/outline/OutlineFilter.ts","../src/pixelate/PixelateFilter.ts","../src/radial-blur/RadialBlurFilter.ts","../src/reflection/ReflectionFilter.ts","../src/rgb-split/RGBSplitFilter.ts","../src/shockwave/ShockwaveFilter.ts","../src/simple-lightmap/SimpleLightmapFilter.ts","../src/simplex-noise/SimplexNoiseFilter.ts","../src/tilt-shift/TiltShiftAxisFilter.ts","../src/tilt-shift/TiltShiftFilter.ts","../src/twist/TwistFilter.ts","../src/zoom-blur/ZoomBlurFilter.ts"],"sourcesContent":["import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './adjustment.frag';\nimport source from './adjustment.wgsl';\n\n/** Options for the AdjustmentFilter constructor */\nexport interface AdjustmentFilterOptions\n{\n    /**\n     * The amount of luminance\n     * @default 1\n     */\n    gamma?: number;\n    /**\n     * The amount of contrast\n     * @default 1\n     */\n    contrast?: number;\n    /**\n     * The amount of color saturation\n     * @default 1\n     */\n    saturation?: number;\n    /**\n     * The overall brightness\n     * @default 1\n     */\n    brightness?: number;\n    /**\n     * The multiplied red channel\n     * @default 1\n     */\n    red?: number;\n    /**\n     * The multiplied green channel\n     * @default 1\n     */\n    green?: number;\n    /**\n     * The multiplied blue channel\n     * @default 1\n     */\n    blue?: number;\n    /**\n     * The overall alpha channel\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * The ability to adjust gamma, contrast, saturation, brightness, alpha or color-channel shift.\n * This is a faster and much simpler to use than\n * {@link http://pixijs.download/release/docs/ColorMatrixFilter.html ColorMatrixFilter}\n * because it does not use a matrix.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/adjustment.png)\n *\n * @class\n * @extends Filter\n */\nexport class AdjustmentFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AdjustmentFilterOptions = {\n        gamma: 1,\n        contrast: 1,\n        saturation: 1,\n        brightness: 1,\n        red: 1,\n        green: 1,\n        blue: 1,\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uGamma: number;\n        uContrast: number;\n        uSaturation: number;\n        uBrightness: number;\n        uColor: Float32Array;\n    };\n\n    /**\n     * @param options - The options of the adjustment filter.\n     */\n    constructor(options?: AdjustmentFilterOptions)\n    {\n        options = { ...AdjustmentFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'adjustment-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                adjustmentUniforms: {\n                    uGamma: { value: options.gamma, type: 'f32' },\n                    uContrast: { value: options.contrast, type: 'f32' },\n                    uSaturation: { value: options.saturation, type: 'f32' },\n                    uBrightness: { value: options.brightness, type: 'f32' },\n                    uColor: {\n                        value: [\n                            options.red,\n                            options.green,\n                            options.blue,\n                            options.alpha,\n                        ],\n                        type: 'vec4<f32>',\n                    },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.adjustmentUniforms.uniforms;\n    }\n\n    /**\n     * Amount of luminance\n     * @default 1\n     */\n    get gamma(): number { return this.uniforms.uGamma; }\n    set gamma(value: number) { this.uniforms.uGamma = value; }\n\n    /**\n     * Amount of contrast\n     * @default 1\n     */\n    get contrast(): number { return this.uniforms.uContrast; }\n    set contrast(value: number) { this.uniforms.uContrast = value; }\n\n    /**\n     * Amount of color saturation\n     * @default 1\n     */\n    get saturation(): number { return this.uniforms.uSaturation; }\n    set saturation(value: number) { this.uniforms.uSaturation = value; }\n\n    /**\n     * The overall brightness\n     * @default 1\n     */\n    get brightness(): number { return this.uniforms.uBrightness; }\n    set brightness(value: number) { this.uniforms.uBrightness = value; }\n\n    /**\n     * The multiplied red channel\n     * @default 1\n     */\n    get red(): number { return this.uniforms.uColor[0]; }\n    set red(value: number) { this.uniforms.uColor[0] = value; }\n\n    /**\n     * The multiplied blue channel\n     * @default 1\n     */\n    get green(): number { return this.uniforms.uColor[1]; }\n    set green(value: number) { this.uniforms.uColor[1] = value; }\n\n    /**\n     * The multiplied green channel\n     * @default 1\n     */\n    get blue(): number { return this.uniforms.uColor[2]; }\n    set blue(value: number) { this.uniforms.uColor[2] = value; }\n\n    /**\n     * The overall alpha channel\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uColor[3]; }\n    set alpha(value: number) { this.uniforms.uColor[3] = value; }\n}\n","import { deprecation, Filter, GlProgram, GpuProgram, TexturePool } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './kawase-blur.frag';\nimport source from './kawase-blur.wgsl';\nimport fragmentClamp from './kawase-blur-clamp.frag';\nimport sourceClamp from './kawase-blur-clamp.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the KawaseBlurFilter constructor. */\nexport interface KawaseBlurFilterOptions\n{\n    /**\n     * The blur of the filter. Should be greater than `0`.\n     * If value is an Array, setting kernels.\n     * @default 4\n     */\n    strength?: number | [number, number];\n    /**\n     * The quality of the filter. Should be an integer greater than `1`\n     * @default 3\n     */\n    quality?: number;\n    /**\n     * Clamp edges, useful for removing dark edges from fullscreen filters or bleeding to the edge of filterArea.\n     * @default false\n     */\n    clamp?: boolean;\n    /**\n     * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number;\n}\n\n/**\n * A much faster blur than Gaussian blur, but more complicated to use.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/kawase-blur.png)\n *\n * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms\n * @class\n * @extends Filter\n */\nexport class KawaseBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: KawaseBlurFilterOptions = {\n        strength: 4,\n        quality: 3,\n        clamp: false,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uOffset: Float32Array;\n    };\n\n    private _pixelSize = { x: 0, y: 0 };\n    private _clamp: boolean;\n    private _kernels: number[] = [];\n    private _blur!: number;\n    private _quality!: number;\n\n    /**\n     * @param options - Options for the KawaseBlurFilter constructor.\n     */\n    constructor(options?: KawaseBlurFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If\n     *        value is an Array, setting kernels.\n     * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.\n     * @param {boolean} [clamp=false] - Clamp edges, useful for removing dark edges\n     *        from fullscreen filters or bleeding to the edge of filterArea.\n     */\n    constructor(blur?: number | number[], quality?: number, clamp?: boolean);\n    /** @ignore */\n    constructor(...args: [KawaseBlurFilterOptions?] | [(number | number[])?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }');\n\n            options = { strength: options as number | [number, number] };\n\n            if (args[1] !== undefined) options.quality = args[1];\n            if (args[2] !== undefined) options.clamp = args[2];\n        }\n\n        options = { ...KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: options?.clamp ? sourceClamp : source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: options?.clamp ? fragmentClamp : fragment,\n            name: 'kawase-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                kawaseBlurUniforms: {\n                    uOffset: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n\n        this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n\n        if (Array.isArray(options.strength))\n        {\n            this.kernels = options.strength;\n        }\n        else if (typeof options.strength === 'number')\n        {\n            this._blur = options.strength;\n            this.quality = options.quality ?? 3;\n        }\n\n        this._clamp = !!options.clamp;\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const uvX = this.pixelSizeX / input.source.width;\n        const uvY = this.pixelSizeY / input.source.height;\n        let offset;\n\n        if (this._quality === 1 || this._blur === 0)\n        {\n            offset = this._kernels[0] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const renderTarget = TexturePool.getSameSizeTexture(input);\n\n            let source = input;\n            let target = renderTarget;\n            let tmp;\n\n            const last = this._quality - 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                offset = this._kernels[i] + 0.5;\n                this.uniforms.uOffset[0] = offset * uvX;\n                this.uniforms.uOffset[1] = offset * uvY;\n                filterManager.applyFilter(this, source, target, true);\n\n                tmp = source;\n                source = target;\n                target = tmp;\n            }\n\n            offset = this._kernels[last] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n\n            filterManager.applyFilter(this, source, output, clearMode);\n            TexturePool.returnTexture(renderTarget);\n        }\n    }\n\n    /**\n      * The amount of blur, value greater than `0`.\n      * @default 4\n      */\n    get strength(): number { return this._blur; }\n    set strength(value: number)\n    {\n        this._blur = value;\n        this._generateKernels();\n    }\n\n    /**\n      * The quality of the filter, integer greater than `1`.\n      * @default 3\n      */\n    get quality(): number { return this._quality; }\n    set quality(value: number)\n    {\n        this._quality = Math.max(1, Math.round(value));\n        this._generateKernels();\n    }\n\n    /**\n      * The kernel size of the blur filter, for advanced usage\n      * @default [0]\n      */\n    get kernels(): number[] { return this._kernels; }\n    set kernels(value: number[])\n    {\n        if (Array.isArray(value) && value.length > 0)\n        {\n            this._kernels = value;\n            this._quality = value.length;\n            this._blur = Math.max(...value);\n        }\n        else\n        {\n            // If value is invalid, set default value\n            this._kernels = [0];\n            this._quality = 1;\n        }\n    }\n\n    /**\n      * The size of the pixels. Large size is blurrier. For advanced usage.\n      * @default {x:1,y:1}\n      */\n    get pixelSize(): PointData { return this._pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            this.pixelSizeX = this.pixelSizeY = value;\n\n            return;\n        }\n\n        if (Array.isArray(value))\n        {\n            this.pixelSizeX = value[0];\n            this.pixelSizeY = value[1];\n\n            return;\n        }\n\n        this._pixelSize = value;\n    }\n\n    /**\n      * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeX(): number { return this.pixelSize.x; }\n    set pixelSizeX(value: number) { this.pixelSize.x = value; }\n\n    /**\n      * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeY(): number { return this.pixelSize.y; }\n    set pixelSizeY(value: number) { this.pixelSize.y = value; }\n\n    /**\n      * Get the if the filter is clamped\n      * @default false\n      */\n    get clamp(): boolean { return this._clamp; }\n\n    /** Update padding based on kernel data */\n    private _updatePadding()\n    {\n        this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n    }\n\n    /** Auto generate kernels by blur & quality */\n    private _generateKernels()\n    {\n        const blur = this._blur;\n        const quality = this._quality;\n        const kernels: number[] = [blur];\n\n        if (blur > 0)\n        {\n            let k = blur;\n            const step = blur / quality;\n\n            for (let i = 1; i < quality; i++)\n            {\n                k -= step;\n                kernels.push(k);\n            }\n        }\n\n        this._kernels = kernels;\n        this._updatePadding();\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './extract-brightness.frag';\nimport source from './extract-brightness.wgsl';\n\nexport interface ExtractBrightnessFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be extracted.\n     */\n    threshold?: number;\n}\n\n/**\n * Internal filter for retrieving the brightness of the source image.\n * @class\n * @private\n */\nexport class ExtractBrightnessFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ExtractBrightnessFilterOptions = {\n        threshold: 0.5\n    };\n\n    public uniforms: {\n        uThreshold: number;\n    };\n\n    constructor(options?: ExtractBrightnessFilterOptions)\n    {\n        options = { ...ExtractBrightnessFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'extract-brightness-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                extractBrightnessUniforms: {\n                    uThreshold: { value: options.threshold, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.extractBrightnessUniforms.uniforms;\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this.uniforms.uThreshold; }\n    set threshold(value: number) { this.uniforms.uThreshold = value; }\n}\n","import {\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter';\nimport fragment from './advanced-bloom.frag';\nimport source from './advanced-bloom.wgsl';\nimport { ExtractBrightnessFilter } from './ExtractBrightnessFilter';\n\n/** Options for the AdvancedBloomFilter constructor. */\nexport interface AdvancedBloomFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be to affect bloom.\n     * @default 1\n     */\n    threshold?: number,\n    /**\n     * To adjust the strength of the bloom. Higher values is more intense brightness.\n     * @default 1\n     */\n    bloomScale?: number,\n    /**\n     * The brightness, lower value is more subtle brightness, higher value is blown-out.\n     * @default 1\n     */\n    brightness?: number,\n    /** The strength of the Blur properties simultaneously */\n    blur?: number,\n    /**\n     * The kernel size of the blur filter.\n     */\n    kernels?: number[],\n    /** The quality of the Blur filter. */\n    quality?: number,\n    /**\n     * The pixel size of the blur filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number,\n}\n\n/**\n * The AdvancedBloomFilter applies a Bloom Effect to an object. Unlike the normal BloomFilter\n * this had some advanced controls for adjusting the look of the bloom. Note: this filter\n * is slower than normal BloomFilter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/advanced-bloom.png)\n *\n * @class\n * @extends Filter\n */\nexport class AdvancedBloomFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AdvancedBloomFilterOptions = {\n        threshold: 0.5,\n        bloomScale: 1,\n        brightness: 1,\n        blur: 8,\n        quality: 4,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uBloomScale: number;\n        uBrightness: number;\n    };\n\n    /** To adjust the strength of the bloom. Higher values is more intense brightness. */\n    public bloomScale = 1;\n\n    /** The brightness, lower value is more subtle brightness, higher value is blown-out. */\n    public brightness = 1;\n\n    private _extractFilter: ExtractBrightnessFilter;\n    private _blurFilter: KawaseBlurFilter;\n\n    /**\n     * @param options - Options for the AdvancedBloomFilter constructor.\n     */\n    constructor(options?: AdvancedBloomFilterOptions)\n    {\n        options = { ...AdvancedBloomFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'advanced-bloom-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                advancedBloomUniforms: {\n                    uBloomScale: { value: options.bloomScale, type: 'f32' },\n                    uBrightness: { value: options.brightness, type: 'f32' },\n                },\n                uMapTexture: Texture.WHITE,\n            },\n        });\n\n        this.uniforms = this.resources.advancedBloomUniforms.uniforms;\n\n        this._extractFilter = new ExtractBrightnessFilter({\n            threshold: options.threshold\n        });\n\n        this._blurFilter = new KawaseBlurFilter({\n            strength: options.kernels as [number, number] ?? options.blur,\n            quality: options.kernels ? undefined : options.quality,\n        });\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const brightTarget = TexturePool.getSameSizeTexture(input);\n\n        this._extractFilter.apply(filterManager, input, brightTarget, true);\n\n        const bloomTarget = TexturePool.getSameSizeTexture(input);\n\n        this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);\n\n        this.uniforms.uBloomScale = this.bloomScale;\n        this.uniforms.uBrightness = this.brightness;\n\n        this.resources.uMapTexture = bloomTarget.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n\n        TexturePool.returnTexture(bloomTarget);\n        TexturePool.returnTexture(brightTarget);\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this._extractFilter.threshold; }\n    set threshold(value: number) { this._extractFilter.threshold = value; }\n\n    /** The kernels of the Blur Filter */\n    get kernels(): number[] { return this._blurFilter.kernels; }\n    set kernels(value: number[]) { this._blurFilter.kernels = value; }\n\n    /**\n     * The strength of the Blur properties simultaneously\n     * @default 2\n     */\n    get blur(): number { return this._blurFilter.strength; }\n    set blur(value: number) { this._blurFilter.strength = value; }\n\n    /**\n     * The quality of the Blur Filter\n     * @default 4\n     */\n    get quality(): number { return this._blurFilter.quality; }\n    set quality(value: number) { this._blurFilter.quality = value; }\n\n    /**\n     * The pixel size of the Kawase Blur filter\n     * @default {x:1,y:1}\n     */\n    get pixelSize(): PointData { return this._blurFilter.pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._blurFilter.pixelSize = value;\n    }\n\n    /**\n     * The horizontal pixelSize of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeX(): number { return this._blurFilter.pixelSizeX; }\n    set pixelSizeX(value: number) { this._blurFilter.pixelSizeX = value; }\n\n    /**\n     * The vertical pixel size of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeY(): number { return this._blurFilter.pixelSizeY; }\n    set pixelSizeY(value: number) { this._blurFilter.pixelSizeY = value; }\n}\n","import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './ascii.frag';\nimport source from './ascii.wgsl';\n\n// This WebGPU filter has been ported from the WebGL renderer that was originally created by Vico (@vicocotea)\n\n/** Options for AsciiFilter constructor. */\nexport interface AsciiFilterOptions\n{\n    /**\n     * The pixel size used by the filter\n     * @default 8\n     */\n    size?: number;\n    /**\n     * A color to set the ascii characters to. If not set, the color will be taken from the source.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * Determine whether or not to replace the source colors with the provided.\n     *\n     * Will automatically be assigned to `true` if `color` is provided.\n     * Set `replaceColor` to `false` to prevent that.\n     * @default false\n     */\n    replaceColor?: boolean;\n}\n\n/**\n * An ASCII filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/ascii.png)\n *\n * @class\n * @extends Filter\n */\nexport class AsciiFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AsciiFilterOptions = {\n        size: 8,\n        color: 0xffffff,\n        replaceColor: false,\n    };\n\n    public uniforms: {\n        uSize: number;\n        uColor: Float32Array;\n        uReplaceColor: number;\n    };\n\n    private _color!: Color;\n\n    /**\n     * Constructor.\n     * @param {AsciiFilterOptions} options - The options of the ASCII filter.\n     */\n    constructor(options?: AsciiFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [size=8] - Size of the font\n     */\n    constructor(size: number);\n    /** @ignore */\n    constructor(...args: [AsciiFilterOptions?] | [number])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }');\n\n            options = { size: options };\n        }\n\n        const replaceColor = options?.color && options.replaceColor !== false;\n\n        options = { ...AsciiFilter.DEFAULT_OPTIONS, ...options } as AsciiFilterOptions;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'ascii-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                asciiUniforms: {\n                    uSize: { value: options.size, type: 'f32' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uReplaceColor: { value: Number(replaceColor), type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.asciiUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0xffffff;\n    }\n\n    /**\n     * The pixel size used by the filter.\n     * @default 8\n     */\n    get size(): number { return this.uniforms.uSize; }\n    set size(value: number) { this.uniforms.uSize = value; }\n\n    /**\n     * The resulting color of the ascii characters, as a 3 component RGB or numerical hex\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Determine whether or not to replace the source colors with the provided.\n     */\n    get replaceColor(): boolean { return this.uniforms.uReplaceColor > 0.5; }\n    set replaceColor(value: boolean) { this.uniforms.uReplaceColor = value ? 1 : 0; }\n}\n","import {\n    BlurFilter,\n    BlurFilterOptions,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './backdrop-blur-blend.frag';\nimport wgslFragment from './backdrop-blur-blend.wgsl';\n\n/**\n * The BackdropBlurFilter applies a Gaussian blur to everything behind an object, and then draws the object on top of it.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/backdrop-blur.png)\n *\n * @class\n * @extends BlurFilter\n */\nexport class BackdropBlurFilter extends BlurFilter\n{\n    private _blendPass: Filter;\n\n    /**\n     * @param options - The options of the blur filter.\n     */\n    constructor(options?: BlurFilterOptions)\n    {\n        super(options);\n\n        this.blendRequired = true;\n        this.padding = 0;\n\n        this._blendPass = new Filter({\n            gpuProgram: GpuProgram.from({\n                vertex: {\n                    source: wgslVertex,\n                    entryPoint: 'mainVertex',\n                },\n                fragment: {\n                    source: wgslFragment,\n                    entryPoint: 'mainFragment',\n                },\n            }),\n            glProgram: GlProgram.from({\n                vertex,\n                fragment,\n                name: 'drop-shadow-filter',\n            }),\n            resources: {\n                uBackground: Texture.EMPTY,\n            },\n        });\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        // @ts-expect-error - this should probably not be grabbed from a private property\n        const backTexture = filterManager._activeFilterData.backTexture;\n\n        const blurredBackground = TexturePool.getSameSizeTexture(input);\n\n        super.apply(filterManager, backTexture, blurredBackground, true);\n\n        this._blendPass.resources.uBackground = blurredBackground.source;\n        this._blendPass.apply(filterManager, input, output, clearMode);\n\n        TexturePool.returnTexture(blurredBackground);\n    }\n\n    protected updatePadding(): void\n    {\n        this.padding = 0;\n    }\n}\n","import { Color, ColorSource, DEG_TO_RAD, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './bevel.frag';\nimport source from './bevel.wgsl';\n\n/** Options for the BevelFilter constructor. */\nexport interface BevelFilterOptions\n{\n    /**\n     * The angle of the light in degrees\n     * @default 45\n     */\n    rotation?: number,\n    /**\n     * The thickness of the bevel\n     * @default 2\n     */\n    thickness?: number,\n    /**\n     * The color value of the left & top bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    lightColor?: ColorSource,\n    /**\n     * The alpha value of the left & top bevel.\n     * @default 0.7\n     */\n    lightAlpha?: number,\n    /**\n     * The color value of the right & bottom bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    shadowColor?: ColorSource,\n    /**\n     * The alpha value of the right & bottom bevel.\n     * @default 0.7\n     */\n    shadowAlpha?: number,\n}\n\n/**\n * Bevel Filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bevel.png)\n *\n * @class\n * @extends Filter\n */\nexport class BevelFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BevelFilterOptions = {\n        rotation: 45,\n        thickness: 2,\n        lightColor: 0xffffff,\n        lightAlpha: 0.7,\n        shadowColor: 0x000000,\n        shadowAlpha: 0.7,\n    };\n\n    public uniforms: {\n        uLightColor: Float32Array;\n        uLightAlpha: number;\n        uShadowColor: Float32Array;\n        uShadowAlpha: number;\n        uTransform: Float32Array;\n    };\n\n    private _thickness!: number;\n    private _rotation!: number;\n    private _lightColor: Color;\n    private _shadowColor: Color;\n\n    /**\n     * @param options - Options for the BevelFilter constructor.\n     */\n    constructor(options?: BevelFilterOptions)\n    {\n        options = { ...BevelFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'bevel-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                bevelUniforms: {\n                    uLightColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uLightAlpha: { value: options.lightAlpha, type: 'f32' },\n                    uShadowColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uShadowAlpha: { value: options.shadowAlpha, type: 'f32' },\n                    uTransform: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n            // Workaround: https://github.com/pixijs/filters/issues/230\n            // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image\n            // To solve this problem, a padding of 1 put on the filter should suffice\n            padding: 1,\n        });\n\n        this.uniforms = this.resources.bevelUniforms.uniforms;\n        this._lightColor = new Color();\n        this._shadowColor = new Color();\n        this.lightColor = options.lightColor ?? 0xffffff;\n        this.shadowColor = options.shadowColor ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * The angle of the light in degrees\n     * @default 45\n     */\n    get rotation(): number { return this._rotation / DEG_TO_RAD; }\n    set rotation(value: number)\n    {\n        this._rotation = value * DEG_TO_RAD;\n        this._updateTransform();\n    }\n\n    /**\n     * The thickness of the bevel\n     * @default 2\n     */\n    get thickness(): number { return this._thickness; }\n    set thickness(value: number)\n    {\n        this._thickness = value;\n        this._updateTransform();\n    }\n\n    /**\n     * The color value of the left & top bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    get lightColor(): ColorSource { return this._lightColor.value as ColorSource; }\n    set lightColor(value: ColorSource)\n    {\n        this._lightColor.setValue(value);\n        const [r, g, b] = this._lightColor.toArray();\n\n        this.uniforms.uLightColor[0] = r;\n        this.uniforms.uLightColor[1] = g;\n        this.uniforms.uLightColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the left & top bevel.\n     * @default 0.7\n     */\n    get lightAlpha(): number { return this.uniforms.uLightAlpha; }\n    set lightAlpha(value: number) { this.uniforms.uLightAlpha = value; }\n\n    /**\n     * The color value of the right & bottom bevel.\n     * @default 0xffffff\n     */\n    get shadowColor(): ColorSource { return this._shadowColor.value as ColorSource; }\n    set shadowColor(value: ColorSource)\n    {\n        this._shadowColor.setValue(value);\n        const [r, g, b] = this._shadowColor.toArray();\n\n        this.uniforms.uShadowColor[0] = r;\n        this.uniforms.uShadowColor[1] = g;\n        this.uniforms.uShadowColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the right & bottom bevel.\n     * @default 0.7\n     */\n    get shadowAlpha(): number { return this.uniforms.uShadowAlpha; }\n    set shadowAlpha(value: number) { this.uniforms.uShadowAlpha = value; }\n\n    /**\n     * Update the transform matrix of offset angle.\n     * @private\n     */\n    private _updateTransform()\n    {\n        this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation);\n        this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);\n    }\n}\n","/* eslint-disable max-len */\nimport {\n    AlphaFilter,\n    BlurFilterPass,\n    deprecation,\n    FilterSystem,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\n\ntype DeprecatedBlurValue = number | PointData | number[];\n\n/** Options for the BloomFilter constructor. */\nexport interface BloomFilterOptions\n{\n    /**\n     * Sets the strength of the blur. If only a number is provided, it will assign to both x and y.\n     * @default {x:2,y:2}\n     */\n    strength?: PointData | number;\n    /**\n     * The quality of the blur.\n     * @default 4\n     */\n    quality?: number;\n    /**\n     * The resolution of the blurX & blurY filter.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * The kernel size of the blur filter. Must be an odd number between 5 and 15 (inclusive).\n     * @default 5\n     */\n    kernelSize?: number;\n}\n\n/**\n * The BloomFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bloom.png)\n *\n * @class\n * @extends Filter\n */\nexport class BloomFilter extends AlphaFilter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BloomFilterOptions = {\n        strength: { x: 2, y: 2 },\n        quality: 4,\n        resolution: 1,\n        kernelSize: 5\n    };\n\n    private _blurXFilter: BlurFilterPass;\n    private _blurYFilter: BlurFilterPass;\n    private _strength: PointData;\n\n    /**\n     * @param {BloomFilterOptions} options - Options for the BloomFilter constructor.\n     */\n    constructor(options?: BloomFilterOptions);\n    /**\n    * @deprecated since 6.0.0\n    *\n    * @param {number|PIXI.PointData|number[]} [blur=2] - Sets the strength of both the blurX and blurY properties simultaneously\n    * @param {number} [quality=4] - The quality of the blurX & blurY filter.\n    * @param {number} [resolution=1] - The resolution of the blurX & blurY filter.\n    * @param {number} [kernelSize=5] - The kernelSize of the blurX & blurY filter.Options: 5, 7, 9, 11, 13, 15.\n    */\n    constructor(blur?: DeprecatedBlurValue, quality?: number, resolution?: number, kernelSize?: number);\n    /** @ignore */\n    constructor(...args: [BloomFilterOptions?] | [DeprecatedBlurValue?, number?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || ('x' in options && 'y' in options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }');\n\n            let strength = options;\n\n            if (Array.isArray(strength)) strength = { x: strength[0], y: strength[1] };\n\n            options = { strength };\n\n            if (args[1] !== undefined) options.quality = args[1];\n            if (args[2] !== undefined) options.resolution = args[2];\n            if (args[3] !== undefined) options.kernelSize = args[3];\n        }\n\n        options = { ...BloomFilter.DEFAULT_OPTIONS, ...options } as BloomFilterOptions;\n\n        super();\n\n        this._strength = { x: 2, y: 2 };\n\n        if (options.strength)\n        {\n            if (typeof options.strength === 'number')\n            {\n                this._strength.x = options.strength;\n                this._strength.y = options.strength;\n            }\n            else\n            {\n                this._strength.x = options.strength.x;\n                this._strength.y = options.strength.y;\n            }\n        }\n\n        this._blurXFilter = new BlurFilterPass({\n            ...options,\n            horizontal: true,\n            strength: this.strengthX,\n        });\n\n        this._blurYFilter = new BlurFilterPass({\n            ...options,\n            horizontal: false,\n            strength: this.strengthY,\n        });\n\n        this._blurYFilter.blendMode = 'screen';\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clear: boolean,\n    ): void\n    {\n        const renderTarget = TexturePool.getSameSizeTexture(input);\n\n        filterManager.applyFilter(this, input, output, clear);\n        this._blurXFilter.apply(filterManager, input, renderTarget, true);\n        this._blurYFilter.apply(filterManager, renderTarget, output, false);\n\n        TexturePool.returnTexture(renderTarget);\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     */\n    get strength(): PointData { return this._strength; }\n    set strength(value: PointData | number)\n    {\n        this._strength = typeof value === 'number' ? { x: value, y: value } : value;\n        this._updateStrength();\n    }\n\n    /**\n     * Sets the strength of the blur on the `x` axis\n     * @default 2\n     */\n    get strengthX(): number { return this.strength.x; }\n    set strengthX(value: number)\n    {\n        this.strength.x = value;\n        this._updateStrength();\n    }\n\n    /**\n     * Sets the strength of the blur on the `y` axis\n     * @default 2\n     */\n    get strengthY(): number { return this.strength.y; }\n    set strengthY(value: number)\n    {\n        this.strength.y = value;\n        this._updateStrength();\n    }\n\n    private _updateStrength()\n    {\n        this._blurXFilter.blur = this.strengthX;\n        this._blurYFilter.blur = this.strengthY;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     * @see BloomFilter#strength\n     */\n    get blur(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blur is deprecated, please use BloomFilter.strength instead');\n\n        return this.strengthX;\n    }\n    set blur(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blur is deprecated, please use BloomFilter.strength instead');\n\n        this.strength = value;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of the blurX property\n     * @default 2\n     * @see BloomFilter#strengthX\n     */\n    get blurX(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead');\n\n        return this.strengthX;\n    }\n    set blurX(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead');\n\n        this.strengthX = value;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of the blurY property\n     * @default 2\n     * @see BloomFilter#strengthY\n     */\n    get blurY(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead');\n\n        return this.strengthY;\n    }\n    set blurY(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead');\n\n        this.strengthY = value;\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './bulge-pinch.frag';\nimport source from './bulge-pinch.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n// This WebGPU filter has been ported from the WebGL renderer that was originally created by Julien CLEREL (@JuloxRox)\n\n/** Options for the BulgePinchFilter constructor. */\nexport interface BulgePinchFilterOptions\n{\n    /**\n     * Offset coordinates to change the position of the center of the circle of effect.\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[] | number;\n    /**\n     * The radius of the circle of effect\n     * @default 100\n     */\n    radius?: number;\n    /**\n     * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n     * @default 1\n     */\n    strength?: number;\n}\n\n/**\n * Bulges or pinches the image in a circle.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bulge-pinch.gif)\n *\n * @class\n * @extends Filter\n */\nexport class BulgePinchFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BulgePinchFilterOptions = {\n        center: { x: 0.5, y: 0.5 },\n        radius: 100,\n        strength: 1\n    };\n\n    public uniforms: {\n        uDimensions: Float32Array;\n        uCenter: PointData;\n        uRadius: number;\n        uStrength: number;\n    };\n\n    /**\n     * @param options - Options for the BulgePinchFilter constructor.\n     */\n    constructor(options?: BulgePinchFilterOptions)\n    {\n        options = { ...BulgePinchFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'bulge-pinch-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                bulgePinchUniforms: {\n                    uDimensions: { value: [0, 0], type: 'vec2<f32>' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uRadius: { value: options.radius, type: 'f32' },\n                    uStrength: { value: options.strength, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.bulgePinchUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords.\n     * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right\n     * @default {x:0.5,y:0.5}\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.uniforms.uCenter.x; }\n    set centerX(value: number) { this.uniforms.uCenter.x = value; }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `y` axis\n     * @default 0\n     */\n    get centerY(): number { return this.uniforms.uCenter.y; }\n    set centerY(value: number) { this.uniforms.uCenter.y = value; }\n\n    /**\n     * The radius of the circle of effect\n     * @default 100\n     */\n    get radius(): number { return this.uniforms.uRadius; }\n    set radius(value: number) { this.uniforms.uRadius = value; }\n\n    /**\n     * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n     * @default 1\n     */\n    get strength(): number { return this.uniforms.uStrength; }\n    set strength(value: number) { this.uniforms.uStrength = value; }\n}\n","// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.stringify = (function() {\n\n  var visitor = {\n\n    'visit_linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_gradient': function(node) {\n      var orientation = visitor.visit(node.orientation);\n      if (orientation) {\n        orientation += ', ';\n      }\n\n      return node.type + '(' + orientation + visitor.visit(node.colorStops) + ')';\n    },\n\n    'visit_shape': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at),\n          style = visitor.visit(node.style);\n\n      if (style) {\n        result += ' ' + style;\n      }\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_default-radial': function(node) {\n      var result = '',\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += at;\n      }\n      return result;\n    },\n\n    'visit_extent-keyword': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_position-keyword': function(node) {\n      return node.value;\n    },\n\n    'visit_position': function(node) {\n      return visitor.visit(node.value.x) + ' ' + visitor.visit(node.value.y);\n    },\n\n    'visit_%': function(node) {\n      return node.value + '%';\n    },\n\n    'visit_em': function(node) {\n      return node.value + 'em';\n    },\n\n    'visit_px': function(node) {\n      return node.value + 'px';\n    },\n\n    'visit_literal': function(node) {\n      return visitor.visit_color(node.value, node);\n    },\n\n    'visit_hex': function(node) {\n      return visitor.visit_color('#' + node.value, node);\n    },\n\n    'visit_rgb': function(node) {\n      return visitor.visit_color('rgb(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_rgba': function(node) {\n      return visitor.visit_color('rgba(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_color': function(resultColor, node) {\n      var result = resultColor,\n          length = visitor.visit(node.length);\n\n      if (length) {\n        result += ' ' + length;\n      }\n      return result;\n    },\n\n    'visit_angular': function(node) {\n      return node.value + 'deg';\n    },\n\n    'visit_directional': function(node) {\n      return 'to ' + node.value;\n    },\n\n    'visit_array': function(elements) {\n      var result = '',\n          size = elements.length;\n\n      elements.forEach(function(element, i) {\n        result += visitor.visit(element);\n        if (i < size - 1) {\n          result += ', ';\n        }\n      });\n\n      return result;\n    },\n\n    'visit': function(element) {\n      if (!element) {\n        return '';\n      }\n      var result = '';\n\n      if (element instanceof Array) {\n        return visitor.visit_array(element, result);\n      } else if (element.type) {\n        var nodeVisitor = visitor['visit_' + element.type];\n        if (nodeVisitor) {\n          return nodeVisitor(element);\n        } else {\n          throw Error('Missing visitor visit_' + element.type);\n        }\n      } else {\n        throw Error('Invalid node.');\n      }\n    }\n\n  };\n\n  return function(root) {\n    return visitor.visit(root);\n  };\n})();\n\n// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.parse = (function() {\n\n  var tokens = {\n    linearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(linear\\-gradient)/i,\n    repeatingLinearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-linear\\-gradient)/i,\n    radialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(radial\\-gradient)/i,\n    repeatingRadialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-radial\\-gradient)/i,\n    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,\n    extentKeywords: /^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,\n    positionKeywords: /^(left|center|right|top|bottom)/i,\n    pixelValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,\n    percentageValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,\n    emValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,\n    angleValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,\n    startCall: /^\\(/,\n    endCall: /^\\)/,\n    comma: /^,/,\n    hexColor: /^\\#([0-9a-fA-F]+)/,\n    literalColor: /^([a-zA-Z]+)/,\n    rgbColor: /^rgb/i,\n    rgbaColor: /^rgba/i,\n    number: /^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/\n  };\n\n  var input = '';\n\n  function error(msg) {\n    var err = new Error(input + ': ' + msg);\n    err.source = input;\n    throw err;\n  }\n\n  function getAST() {\n    var ast = matchListDefinitions();\n\n    if (input.length > 0) {\n      error('Invalid input not EOF');\n    }\n\n    return ast;\n  }\n\n  function matchListDefinitions() {\n    return matchListing(matchDefinition);\n  }\n\n  function matchDefinition() {\n    return matchGradient(\n            'linear-gradient',\n            tokens.linearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'repeating-linear-gradient',\n            tokens.repeatingLinearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'radial-gradient',\n            tokens.radialGradient,\n            matchListRadialOrientations) ||\n\n          matchGradient(\n            'repeating-radial-gradient',\n            tokens.repeatingRadialGradient,\n            matchListRadialOrientations);\n  }\n\n  function matchGradient(gradientType, pattern, orientationMatcher) {\n    return matchCall(pattern, function(captures) {\n\n      var orientation = orientationMatcher();\n      if (orientation) {\n        if (!scan(tokens.comma)) {\n          error('Missing comma before color stops');\n        }\n      }\n\n      return {\n        type: gradientType,\n        orientation: orientation,\n        colorStops: matchListing(matchColorStop)\n      };\n    });\n  }\n\n  function matchCall(pattern, callback) {\n    var captures = scan(pattern);\n\n    if (captures) {\n      if (!scan(tokens.startCall)) {\n        error('Missing (');\n      }\n\n      var result = callback(captures);\n\n      if (!scan(tokens.endCall)) {\n        error('Missing )');\n      }\n\n      return result;\n    }\n  }\n\n  function matchLinearOrientation() {\n    return matchSideOrCorner() ||\n      matchAngle();\n  }\n\n  function matchSideOrCorner() {\n    return match('directional', tokens.sideOrCorner, 1);\n  }\n\n  function matchAngle() {\n    return match('angular', tokens.angleValue, 1);\n  }\n\n  function matchListRadialOrientations() {\n    var radialOrientations,\n        radialOrientation = matchRadialOrientation(),\n        lookaheadCache;\n\n    if (radialOrientation) {\n      radialOrientations = [];\n      radialOrientations.push(radialOrientation);\n\n      lookaheadCache = input;\n      if (scan(tokens.comma)) {\n        radialOrientation = matchRadialOrientation();\n        if (radialOrientation) {\n          radialOrientations.push(radialOrientation);\n        } else {\n          input = lookaheadCache;\n        }\n      }\n    }\n\n    return radialOrientations;\n  }\n\n  function matchRadialOrientation() {\n    var radialType = matchCircle() ||\n      matchEllipse();\n\n    if (radialType) {\n      radialType.at = matchAtPosition();\n    } else {\n      var extent = matchExtentKeyword();\n      if (extent) {\n        radialType = extent;\n        var positionAt = matchAtPosition();\n        if (positionAt) {\n          radialType.at = positionAt;\n        }\n      } else {\n        var defaultPosition = matchPositioning();\n        if (defaultPosition) {\n          radialType = {\n            type: 'default-radial',\n            at: defaultPosition\n          };\n        }\n      }\n    }\n\n    return radialType;\n  }\n\n  function matchCircle() {\n    var circle = match('shape', /^(circle)/i, 0);\n\n    if (circle) {\n      circle.style = matchLength() || matchExtentKeyword();\n    }\n\n    return circle;\n  }\n\n  function matchEllipse() {\n    var ellipse = match('shape', /^(ellipse)/i, 0);\n\n    if (ellipse) {\n      ellipse.style =  matchDistance() || matchExtentKeyword();\n    }\n\n    return ellipse;\n  }\n\n  function matchExtentKeyword() {\n    return match('extent-keyword', tokens.extentKeywords, 1);\n  }\n\n  function matchAtPosition() {\n    if (match('position', /^at/, 0)) {\n      var positioning = matchPositioning();\n\n      if (!positioning) {\n        error('Missing positioning value');\n      }\n\n      return positioning;\n    }\n  }\n\n  function matchPositioning() {\n    var location = matchCoordinates();\n\n    if (location.x || location.y) {\n      return {\n        type: 'position',\n        value: location\n      };\n    }\n  }\n\n  function matchCoordinates() {\n    return {\n      x: matchDistance(),\n      y: matchDistance()\n    };\n  }\n\n  function matchListing(matcher) {\n    var captures = matcher(),\n      result = [];\n\n    if (captures) {\n      result.push(captures);\n      while (scan(tokens.comma)) {\n        captures = matcher();\n        if (captures) {\n          result.push(captures);\n        } else {\n          error('One extra comma');\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function matchColorStop() {\n    var color = matchColor();\n\n    if (!color) {\n      error('Expected color definition');\n    }\n\n    color.length = matchDistance();\n    return color;\n  }\n\n  function matchColor() {\n    return matchHexColor() ||\n      matchRGBAColor() ||\n      matchRGBColor() ||\n      matchLiteralColor();\n  }\n\n  function matchLiteralColor() {\n    return match('literal', tokens.literalColor, 0);\n  }\n\n  function matchHexColor() {\n    return match('hex', tokens.hexColor, 1);\n  }\n\n  function matchRGBColor() {\n    return matchCall(tokens.rgbColor, function() {\n      return  {\n        type: 'rgb',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchRGBAColor() {\n    return matchCall(tokens.rgbaColor, function() {\n      return  {\n        type: 'rgba',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchNumber() {\n    return scan(tokens.number)[1];\n  }\n\n  function matchDistance() {\n    return match('%', tokens.percentageValue, 1) ||\n      matchPositionKeyword() ||\n      matchLength();\n  }\n\n  function matchPositionKeyword() {\n    return match('position-keyword', tokens.positionKeywords, 1);\n  }\n\n  function matchLength() {\n    return match('px', tokens.pixelValue, 1) ||\n      match('em', tokens.emValue, 1);\n  }\n\n  function match(type, pattern, captureIndex) {\n    var captures = scan(pattern);\n    if (captures) {\n      return {\n        type: type,\n        value: captures[captureIndex]\n      };\n    }\n  }\n\n  function scan(regexp) {\n    var captures,\n        blankCaptures;\n\n    blankCaptures = /^[\\n\\r\\t\\s]+/.exec(input);\n    if (blankCaptures) {\n        consume(blankCaptures[0].length);\n    }\n\n    captures = regexp.exec(input);\n    if (captures) {\n        consume(captures[0].length);\n    }\n\n    return captures;\n  }\n\n  function consume(size) {\n    input = input.substr(size);\n  }\n\n  return function(code) {\n    input = code.toString();\n    return getAST();\n  };\n})();\n\nexports.parse = GradientParser.parse;\nexports.stringify = GradientParser.stringify;\n","import {\n    AngularNode,\n    ColorStop as CssColorStop,\n    DefaultRadialNode,\n    DirectionalNode,\n    ExtentKeywordNode,\n    GradientNode,\n    parse,\n    ShapeNode\n} from 'gradient-parser';\nimport { Color } from 'pixi.js';\nimport { ColorStop } from './ColorGradientFilter';\n\nexport type ParseResult = {\n    type: number;\n    stops: ColorStop[];\n    angle: number;\n};\n\nexport function parseCssGradient(cssGradient: string): ParseResult\n{\n    const cssGradientNodes: GradientNode[] = parse(trimCssGradient(cssGradient));\n\n    if (cssGradientNodes.length === 0)\n    {\n        throw new Error('Invalid CSS gradient.');\n    }\n    else if (cssGradientNodes.length !== 1)\n    {\n        throw new Error('Unsupported CSS gradient (multiple gradients is not supported).');\n    }\n\n    const cssGradientNode = cssGradientNodes[0];\n\n    const type = typeFromCssType(cssGradientNode.type);\n    const stops = stopsFromCssStops(cssGradientNode.colorStops);\n    const angle = angleFromCssOrientation(cssGradientNode.orientation);\n\n    return {\n        type,\n        stops,\n        angle,\n    };\n}\n\nexport function typeFromCssType(type: string): number\n{\n    const supportedTypes: { [key: string]: number } = {\n        'linear-gradient': 0,\n        'radial-gradient': 1,\n    };\n\n    if (!(type in supportedTypes))\n    {\n        throw new Error(`Unsupported gradient type \"${type}\"`);\n    }\n\n    return supportedTypes[type];\n}\n\nexport function stopsFromCssStops(stops: CssColorStop[]): ColorStop[]\n{\n    const offsets: number[] = offsetsFromCssColorStops(stops);\n    const result: ColorStop[] = [];\n    const color = new Color();\n\n    for (let i = 0; i < stops.length; i++)\n    {\n        const colorString = colorAsStringFromCssStop(stops[i]);\n        const rgbaColor = color.setValue(colorString).toArray();\n\n        result.push({\n            offset: offsets[i],\n            color: rgbaColor.slice(0, 3),\n            alpha: rgbaColor[3]\n        });\n    }\n\n    return result;\n}\n\nexport function colorAsStringFromCssStop(stop: CssColorStop): string\n{\n    switch (stop.type)\n    {\n        case 'hex':\n            return `#${stop.value}`;\n        case 'literal':\n            return stop.value;\n        default:\n            return `${stop.type}(${stop.value.join(',')})`;\n    }\n}\n\nexport function offsetsFromCssColorStops(stops: CssColorStop[]): number[]\n{\n    const offsets: number[] = [];\n    const dynamicOffset = -1;\n\n    for (let i = 0; i < stops.length; i++)\n    {\n        const cssStop = stops[i];\n        let stopOffset = dynamicOffset;\n\n        if (cssStop.type === 'literal')\n        {\n            if (cssStop.length && 'type' in cssStop.length && cssStop.length.type === '%' && 'value' in cssStop.length)\n            {\n                stopOffset = parseFloat(cssStop.length.value) / 100;\n            }\n        }\n\n        offsets.push(stopOffset);\n    }\n\n    const findNextFixedStop = (fromIndex: number): { indexDelta: number; offset: number; } =>\n    {\n        for (let k = fromIndex; k < offsets.length; k++)\n        {\n            if (offsets[k] !== dynamicOffset)\n            {\n                return {\n                    indexDelta: k - fromIndex,\n                    offset: offsets[k]\n                };\n            }\n        }\n\n        return {\n            indexDelta: (offsets.length - 1) - fromIndex,\n            offset: 1.0\n        };\n    };\n\n    let prevFixedOffset = 0;\n\n    for (let i = 0; i < offsets.length; i++)\n    {\n        const offset = offsets[i];\n\n        if (offset !== dynamicOffset)\n        {\n            prevFixedOffset = offset;\n        }\n        else if (i === 0)\n        {\n            offsets[i] = 0;\n        }\n        else if (i + 1 === offsets.length)\n        {\n            offsets[i] = 1.0;\n        }\n        else\n        {\n            const nextFixed = findNextFixedStop(i);\n            const offsetDelta = nextFixed.offset - prevFixedOffset;\n            const stepSize = offsetDelta / (1 + nextFixed.indexDelta);\n\n            for (let s = 0; s <= nextFixed.indexDelta; s++)\n            {\n                offsets[i + s] = prevFixedOffset + ((s + 1) * stepSize);\n            }\n\n            i += nextFixed.indexDelta;\n            prevFixedOffset = offsets[i];\n        }\n    }\n\n    return offsets.map(fixFloatRounding);\n}\n\n// fixes issues like 0.3 - 0.1 = 0.19999999999999998\nfunction fixFloatRounding(value: number): number\n{\n    const maxLength = 6;\n\n    if (value.toString().length > maxLength)\n    {\n        return parseFloat(value.toString().substring(0, maxLength));\n    }\n\n    return value;\n}\n\ntype CssOrientation = DirectionalNode | AngularNode | (ShapeNode | DefaultRadialNode | ExtentKeywordNode)[] | undefined;\n\nexport function angleFromCssOrientation(orientation: CssOrientation): number\n{\n    if (typeof orientation === 'undefined')\n    {\n        return 0;\n    }\n\n    if ('type' in orientation && 'value' in orientation)\n    {\n        switch (orientation.type)\n        {\n            case 'angular':\n                return parseFloat(orientation.value);\n            case 'directional':\n                return angleFromDirectionalValue(orientation.value);\n        }\n    }\n\n    return 0;\n}\n\nexport function angleFromDirectionalValue(value: string): number\n{\n    const supportedValues: { [key: string]: number } = {\n        left: 270,\n        top: 0,\n        bottom: 180,\n        right: 90,\n        'left top': 315,\n        'top left': 315,\n        'left bottom': 225,\n        'bottom left': 225,\n        'right top': 45,\n        'top right': 45,\n        'right bottom': 135,\n        'bottom right': 135,\n    };\n\n    if (!(value in supportedValues))\n    {\n        throw new Error(`Unsupported directional value \"${value}\"`);\n    }\n\n    return supportedValues[value];\n}\n\nexport function trimCssGradient(value: string) : string\n{\n    let value_ = value.replace(/\\s{2,}/gu, ' ');\n\n    value_ = value_.replace(/;/g, '');\n    value_ = value_.replace(/ ,/g, ',');\n    value_ = value_.replace(/\\( /g, '(');\n    value_ = value_.replace(/ \\)/g, ')');\n\n    return value_.trim();\n}\n","import { Color, ColorSource, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport fragment from './color-gradient.frag';\nimport vertex from './color-gradient.vert';\nimport source from './color-gradient.wgsl';\nimport { parseCssGradient } from './CssGradientParser';\n\n/** Color stop object. */\nexport interface ColorStop\n{\n    offset: number;\n    color: ColorSource;\n    alpha: number;\n}\n\n/** Options for ColorGradientFilter constructor. */\nexport interface ColorGradientFilterOptions\n{\n    /**\n     * Linear = 0, Radial = 1, Conic = 2\n     * @default ColorGradientFilter.LINEAR\n     */\n    type: number;\n    /** Collection of stops, must be 2+ */\n    stops: ColorStop[];\n    /**\n     * Angle for linear gradients, in degrees.\n     * @default 90\n     */\n    angle?: number;\n    /**\n     * Alpha value for the gradient.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Maximum number of colors to render (0 = no limit)\n     * @default 0\n     */\n    maxColors?: number;\n    /**\n     * If true, the gradient will replace the existing color, otherwise it will be multiplied with it\n     * @default false\n     */\n    replace?: boolean;\n}\n\n/** Options for CSS-style gradient for use with constructor. */\nexport interface ColorGradientFilterCSSOptions\n{\n    /** CSS-style gradient string */\n    css: string;\n    /**\n     * Alpha value for the gradient.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Maximum number of colors to render (0 = no limit)\n     * @default 0\n     */\n    maxColors?: number;\n}\n\nconst ANGLE_OFFSET = 90; // align degrees with CSS\n\nfunction sortColorStops(stops: ColorStop[]): ColorStop[]\n{\n    return [...stops].sort((a, b) => a.offset - b.offset);\n}\n\n/**\n * Render a colored gradient.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-gradient.png)\n *\n * @class\n * @extends Filter\n */\nexport class ColorGradientFilter extends Filter\n{\n    /** Gradient types */\n    static readonly LINEAR = 0;\n    static readonly RADIAL = 1;\n    static readonly CONIC = 2;\n\n    /** Default constructor options */\n    public static readonly defaults: ColorGradientFilterOptions = {\n        type: ColorGradientFilter.LINEAR,\n        stops: [\n            { offset: 0.0, color: 0xff0000, alpha: 1.0 },\n            { offset: 1.0, color: 0x0000ff, alpha: 1.0 },\n        ],\n        alpha: 1.0,\n        angle: 90.0,\n        maxColors: 0,\n        replace: false,\n    };\n\n    public baseUniforms: {\n        uOptions: Float32Array;\n        uCounts: Float32Array;\n    };\n\n    public stopsUniforms: {\n        uColors: Float32Array;\n        uStops: Float32Array;\n    };\n\n    private _stops: ColorStop[] = [];\n\n    /**\n     * @param options - Options for the ColorGradientFilter constructor.\n     */\n    constructor(options?: ColorGradientFilterOptions | ColorGradientFilterCSSOptions)\n    {\n        if (options && 'css' in options)\n        {\n            options = {\n                ...parseCssGradient(options.css || ''),\n                alpha: options.alpha ?? ColorGradientFilter.defaults.alpha,\n                maxColors: options.maxColors ?? ColorGradientFilter.defaults.maxColors,\n            };\n        }\n        else\n        {\n            options = { ...ColorGradientFilter.defaults, ...options };\n        }\n\n        if (!options.stops || options.stops.length < 2)\n        {\n            throw new Error('ColorGradientFilter requires at least 2 color stops.');\n        }\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-gradient-filter',\n        });\n\n        const maxStops = 32;\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                baseUniforms: {\n                    uOptions: {\n                        value: [\n                            // Gradient Type\n                            options.type,\n                            // Gradient Angle\n                            options.angle ?? ANGLE_OFFSET,\n                            // Master Alpha\n                            options.alpha,\n                            // Replace Base Color\n                            options.replace ? 1 : 0,\n                        ],\n                        type: 'vec4<f32>',\n                    },\n                    uCounts: {\n                        value: [\n                            // Number of Stops\n                            options.stops.length,\n                            // Max Gradient Colors\n                            options.maxColors,\n                        ],\n                        type: 'vec2<f32>',\n                    },\n                },\n                stopsUniforms: {\n                    uColors: { value: new Float32Array(maxStops * 3), type: 'vec3<f32>', size: maxStops },\n\n                    // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?\n                    uStops: { value: new Float32Array(maxStops * 4), type: 'vec4<f32>', size: maxStops },\n                }\n            },\n        });\n\n        this.baseUniforms = this.resources.baseUniforms.uniforms;\n        this.stopsUniforms = this.resources.stopsUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    get stops(): ColorStop[]\n    {\n        return this._stops;\n    }\n\n    set stops(stops: ColorStop[])\n    {\n        const sortedStops = sortColorStops(stops);\n        const color = new Color();\n        let r;\n        let g;\n        let b;\n\n        for (let i = 0; i < sortedStops.length; i++)\n        {\n            color.setValue(sortedStops[i].color);\n            const indexStart = i * 3;\n\n            [r, g, b] = color.toArray();\n            this.stopsUniforms.uColors[indexStart] = r;\n            this.stopsUniforms.uColors[indexStart + 1] = g;\n            this.stopsUniforms.uColors[indexStart + 2] = b;\n\n            this.stopsUniforms.uStops[i * 4] = sortedStops[i].offset;\n            this.stopsUniforms.uStops[(i * 4) + 1] = sortedStops[i].alpha;\n        }\n\n        this.baseUniforms.uCounts[0] = sortedStops.length;\n        this._stops = sortedStops;\n    }\n\n    /**\n   * The type of gradient\n   * @default ColorGradientFilter.LINEAR\n   */\n    get type(): number { return this.baseUniforms.uOptions[0]; }\n    set type(value: number) { this.baseUniforms.uOptions[0] = value; }\n\n    /**\n   * The angle of the gradient in degrees\n   * @default 90\n   */\n    get angle(): number { return this.baseUniforms.uOptions[1] + ANGLE_OFFSET; }\n    set angle(value: number) { this.baseUniforms.uOptions[1] = value - ANGLE_OFFSET; }\n\n    /**\n   * The alpha value of the gradient (0-1)\n   * @default 1\n   */\n    get alpha(): number { return this.baseUniforms.uOptions[2]; }\n    set alpha(value: number) { this.baseUniforms.uOptions[2] = value; }\n\n    /**\n   * The maximum number of colors to render (0 = no limit)\n   * @default 0\n   */\n    get maxColors(): number { return this.baseUniforms.uCounts[1]; }\n    set maxColors(value: number) { this.baseUniforms.uCounts[1] = value; }\n\n    /**\n     * If true, the gradient will replace the existing color, otherwise it\n     * will be multiplied with it\n     * @default false\n     */\n    get replace(): boolean { return this.baseUniforms.uOptions[3] > 0.5; }\n    set replace(value: boolean) { this.baseUniforms.uOptions[3] = value ? 1 : 0; }\n}\n\n","import { deprecation, Filter, GlProgram, GpuProgram, SCALE_MODE, Texture, TextureSource } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-map.frag';\nimport source from './color-map.wgsl';\n\ntype ColorMapTexture = TextureSource | Texture;\n\n/** Options for the ColorMapFilter constructor. */\nexport interface ColorMapFilterOptions\n{\n    /** The colorMap texture of the filter. */\n    colorMap: ColorMapTexture;\n    /**\n     *  The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.\n     * @default 1\n     */\n    mix?: number;\n    /**\n     * Whether use NEAREST scale mode for `colorMap` texture.\n     * @default false\n     */\n    nearest?: boolean;\n}\n\n/**\n * The ColorMapFilter applies a color-map effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-map.png)\n *\n * @class\n * @extends Filter\n */\nexport class ColorMapFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ColorMapFilterOptions = {\n        colorMap: Texture.WHITE,\n        nearest: false,\n        mix: 1\n    };\n\n    public uniforms: {\n        uMix: number;\n        uSize: number;\n        uSliceSize: number;\n        uSlicePixelSize: number;\n        uSliceInnerSize: number;\n    };\n\n    private _size = 0;\n    private _sliceSize = 0;\n    private _slicePixelSize = 0;\n    private _sliceInnerSize = 0;\n    private _nearest = false;\n    private _scaleMode: SCALE_MODE = 'linear';\n    private _colorMap!: ColorMapTexture;\n\n    /**\n     * @param options - Options for the ColorMapFilter constructor.\n     */\n    constructor(options: ColorMapFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {HTMLImageElement|HTMLCanvasElement|PIXI.BaseTexture|PIXI.Texture} [colorMap] - The\n     *        colorMap texture of the filter.\n     * @param {boolean} [nearest=false] - Whether use NEAREST for colorMap texture.\n     * @param {number} [mix=1] - The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.\n     */\n    constructor(colorMap: ColorMapTexture, nearest?: boolean, mix?: number);\n    /** @ignore */\n    constructor(...args: [ColorMapFilterOptions] | [ColorMapTexture, boolean?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Texture || options instanceof TextureSource)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }');\n\n            options = { colorMap: options };\n\n            if (args[1] !== undefined) options.nearest = args[1];\n            if (args[2] !== undefined) options.mix = args[2];\n        }\n\n        options = { ...ColorMapFilter.DEFAULT_OPTIONS, ...options };\n\n        if (!options.colorMap) throw Error('No color map texture source was provided to ColorMapFilter');\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-map-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorMapUniforms: {\n                    uMix: { value: options.mix, type: 'f32' },\n                    uSize: { value: 0, type: 'f32' },\n                    uSliceSize: { value: 0, type: 'f32' },\n                    uSlicePixelSize: { value: 0, type: 'f32' },\n                    uSliceInnerSize: { value: 0, type: 'f32' },\n                },\n                uMapTexture: options.colorMap.source,\n                uMapSampler: options.colorMap.source.style,\n            },\n        });\n\n        this.uniforms = this.resources.colorMapUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */\n    get mix(): number { return this.uniforms.uMix; }\n    set mix(value: number) { this.uniforms.uMix = value; }\n\n    /**\n     * The size of one color slice.\n     * @readonly\n     */\n    get colorSize(): number { return this._size; }\n\n    /** The colorMap texture. */\n    get colorMap(): ColorMapTexture { return this._colorMap; }\n    set colorMap(value: ColorMapTexture)\n    {\n        if (!value || value === this.colorMap) return;\n\n        const source = value instanceof Texture ? value.source : value;\n\n        source.style.scaleMode = this._scaleMode;\n        source.autoGenerateMipmaps = false;\n\n        this._size = source.height;\n        this._sliceSize = 1 / this._size;\n        this._slicePixelSize = this._sliceSize / this._size;\n        this._sliceInnerSize = this._slicePixelSize * (this._size - 1);\n\n        this.uniforms.uSize = this._size;\n        this.uniforms.uSliceSize = this._sliceSize;\n        this.uniforms.uSlicePixelSize = this._slicePixelSize;\n        this.uniforms.uSliceInnerSize = this._sliceInnerSize;\n\n        this.resources.uMapTexture = source;\n        this._colorMap = value;\n    }\n\n    /** Whether use NEAREST for colorMap texture. */\n    get nearest(): boolean { return this._nearest; }\n    set nearest(nearest: boolean)\n    {\n        this._nearest = nearest;\n        this._scaleMode = nearest ? 'nearest' : 'linear';\n\n        const texture = this._colorMap;\n\n        if (texture && texture.source)\n        {\n            texture.source.scaleMode = this._scaleMode;\n            texture.source.autoGenerateMipmaps = false;\n            texture.source.style.update();\n            texture.source.update();\n        }\n    }\n\n    /**\n     * If the colorMap is based on canvas,\n     * and the content of canvas has changed, then call `updateColorMap` for update texture.\n     */\n    updateColorMap(): void\n    {\n        const texture = this._colorMap;\n\n        if (texture?.source)\n        {\n            texture.source.update();\n            this.colorMap = texture;\n        }\n    }\n\n    /**\n     * Destroys this filter\n     * @default false\n     */\n    destroy(): void\n    {\n        this._colorMap?.destroy(/** true | TODO: Should base texture be destroyed? **/);\n        super.destroy();\n    }\n}\n","import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-overlay.frag';\nimport source from './color-overlay.wgsl';\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the ColorOverlayFilter constructor. */\nexport interface ColorOverlayFilterOptions\n{\n    /**\n     * The color of the overlay\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the overlay\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * Overlay a source graphic with a color.<br>\n *\n * @class\n * @extends Filter\n */\nexport class ColorOverlayFilter extends Filter\n{\n    /** Default shockwave filter options */\n    public static readonly DEFAULT_OPTIONS: ColorOverlayFilterOptions = {\n        /** The color of the overlay */\n        color: 0x000000,\n        /** The alpha of the overlay */\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uColor: Float32Array;\n        uAlpha: number;\n    };\n\n    private _color: Color;\n\n    /**\n     * @param options - Options for the ColorOverlayFilter constructor.\n     */\n    constructor(options?: ColorOverlayFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|Array<number>} [color=0x000000] - The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n     * @param {number} [alpha=1] - The alpha value of the color\n     */\n    constructor(color?: DeprecatedColor, alpha?: number);\n    /** @ignore */\n    constructor(...args: [ColorOverlayFilterOptions?] | [DeprecatedColor?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || options instanceof Float32Array)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorOverlayFilter constructor params are now options object. See params: { color, alpha }');\n\n            options = { color: options };\n\n            if (args[1] !== undefined) options.alpha = args[1];\n        }\n\n        options = { ...ColorOverlayFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-overlay-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorOverlayUniforms: {\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.colorOverlayUniforms.uniforms;\n\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n    }\n\n    /**\n     * The over color source\n     * @member {number|Array<number>|Float32Array}\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the color\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n}\n","import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-replace.frag';\nimport source from './color-replace.wgsl';\n\n/**\n * This WebGPU filter has been ported from the WebGL renderer that was originally created by mishaa, updated by timetocode\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n */\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the ColorReplaceFilter constructor. */\nexport interface ColorReplaceFilterOptions\n{\n    /**\n     * The color that will be changed.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xff0000\n     */\n    originalColor?: ColorSource;\n    /**\n     * The resulting color.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    targetColor?: ColorSource;\n    /**\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.4\n     */\n    tolerance?: number;\n}\n\n/**\n * ColorReplaceFilter, originally by mishaa, updated by timetocode\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-replace.png)\n *\n * @class\n * @extends Filter\n *\n * @example\n *  // replaces true red with true blue\n *  someSprite.filters = [new ColorReplaceFilter({\n *   originalColor: [1, 0, 0],\n *   targetColor: [0, 0, 1],\n *   tolerance: 0.001\n *   })];\n *  // replaces the RGB color 220, 220, 220 with the RGB color 225, 200, 215\n *  someOtherSprite.filters = [new ColorReplaceFilter({\n *   originalColor: [220/255.0, 220/255.0, 220/255.0],\n *   targetColor: [225/255.0, 200/255.0, 215/255.0],\n *   tolerance: 0.001\n *   })];\n *  // replaces the RGB color 220, 220, 220 with the RGB color 225, 200, 215\n *  someOtherSprite.filters = [new ColorReplaceFilter({ originalColor: 0xdcdcdc, targetColor: 0xe1c8d7, tolerance: 0.001 })];\n *\n */\nexport class ColorReplaceFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ColorReplaceFilterOptions = {\n        originalColor: 0xff0000,\n        targetColor: 0x000000,\n        tolerance: 0.4\n    };\n\n    public uniforms: {\n        uOriginalColor: Float32Array,\n        uTargetColor: Float32Array,\n        uTolerance: number,\n    };\n\n    private _originalColor: Color;\n    private _targetColor: Color;\n\n    /**\n     * @param options - Options for the ColorReplaceFilter constructor.\n     */\n    constructor(options?: ColorReplaceFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|Array<number>|Float32Array} [originalColor=0xFF0000] - The color that will be changed,\n     *        as a 3 component RGB e.g. `[1.0, 1.0, 1.0]`\n     * @param {number|Array<number>|Float32Array} [newColor=0x000000] - The resulting color, as a 3 component\n     *        RGB e.g. `[1.0, 0.5, 1.0]`\n     * @param {number} [epsilon=0.4] - Tolerance/sensitivity of the floating-point comparison between colors\n     *        (lower = more exact, higher = more inclusive)\n     */\n    constructor(originalColor?: number, newColor?: number, epsilon?: number);\n    /** @ignore */\n    constructor(...args: [ColorReplaceFilterOptions?] | [DeprecatedColor?, DeprecatedColor?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || options instanceof Float32Array)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }');\n\n            options = { originalColor: options };\n\n            if (args[1] !== undefined) options.targetColor = args[1];\n            if (args[2] !== undefined) options.tolerance = args[2];\n        }\n\n        options = { ...ColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-replace-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorReplaceUniforms: {\n                    uOriginalColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uTargetColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uTolerance: { value: options.tolerance, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.colorReplaceUniforms.uniforms;\n\n        this._originalColor = new Color();\n        this._targetColor = new Color();\n        this.originalColor = options.originalColor ?? 0xff0000;\n        this.targetColor = options.targetColor ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * The color that will be changed.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xff0000\n     */\n    get originalColor(): ColorSource { return this._originalColor.value as ColorSource; }\n    set originalColor(value: ColorSource)\n    {\n        this._originalColor.setValue(value);\n        const [r, g, b] = this._originalColor.toArray();\n\n        this.uniforms.uOriginalColor[0] = r;\n        this.uniforms.uOriginalColor[1] = g;\n        this.uniforms.uOriginalColor[2] = b;\n    }\n\n    /**\n      * The resulting color.\n      * @example [1.0, 1.0, 1.0] = 0xffffff\n      * @default 0x000000\n      */\n    get targetColor(): ColorSource { return this._targetColor.value as ColorSource; }\n    set targetColor(value: ColorSource)\n    {\n        this._targetColor.setValue(value);\n        const [r, g, b] = this._targetColor.toArray();\n\n        this.uniforms.uTargetColor[0] = r;\n        this.uniforms.uTargetColor[1] = g;\n        this.uniforms.uTargetColor[2] = b;\n    }\n\n    /**\n      * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n      * @default 0.4\n      */\n    get tolerance(): number { return this.uniforms.uTolerance; }\n    set tolerance(value: number) { this.uniforms.uTolerance = value; }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n     * @member {number|Array<number>|Float32Array}\n     * @default 0x000000\n     * @see ColorReplaceFilter#targetColor\n     */\n    set newColor(value: DeprecatedColor)\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead');\n\n        this.targetColor = value;\n    }\n    get newColor(): DeprecatedColor\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead');\n\n        return this.targetColor as DeprecatedColor;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.4\n     * @see ColorReplaceFilter#tolerance\n     */\n    set epsilon(value: number)\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead');\n\n        this.tolerance = value;\n    }\n    get epsilon(): number\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead');\n\n        return this.tolerance;\n    }\n}\n","import { deprecation, Filter, GlProgram, GpuProgram, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './convolution.frag';\nimport source from './convolution.wgsl';\n\ntype FixedArray<T, L extends number> = [ T, ...Array<T> ] & { length: L };\n\nexport type ConvolutionMatrix = Float32Array | FixedArray<number, 9>;\n\n/** Options for the ConvolutionFilter constructor. */\nexport interface ConvolutionFilterOptions\n{\n    /**\n     * An array of values used for matrix transformation, specified as a 9 point Array\n     * @example\n     * const matrix = new Float32Array(9); // 9 elements of value 0\n     * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n     * @default [0,0,0,0,0,0,0,0,0]\n     */\n    matrix?: ConvolutionMatrix;\n    /**\n     * Width of the object you are transforming\n     * @default 200\n     */\n    width?: number;\n    /**\n     * Height of the object you are transforming\n     * @default 200\n     */\n    height?: number;\n}\n\n/**\n * The ConvolutionFilter class applies a matrix convolution filter effect.\n * A convolution combines pixels in the input image with neighboring pixels to produce a new image.\n * A wide variety of image effects can be achieved through convolutions, including blurring, edge\n * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.\n * See https://docs.gimp.org/2.10/en/gimp-filter-convolution-matrix.html for more info.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/convolution.png)\n *\n * @class\n * @extends Filter\n */\nexport class ConvolutionFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ConvolutionFilterOptions = {\n        matrix: new Float32Array(9),\n        width: 200,\n        height: 200,\n    };\n\n    public uniforms: {\n        uMatrix: ConvolutionMatrix;\n        uTexelSize: PointData;\n    };\n\n    /**\n     * @param options - Options for the ConvolutionFilter constructor.\n     */\n    constructor(options?: ConvolutionFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number[]} [matrix=[0,0,0,0,0,0,0,0,0]] - An array of values used for matrix transformation.\n     *        Specified as a 9 point Array.\n     * @param {number} [width=200] - Width of the object you are transforming\n     * @param {number} [height=200] - Height of the object you are transforming\n     */\n    constructor(matrix: number[], width?: number, height?: number);\n    /** @ignore */\n    constructor(...args: [ConvolutionFilterOptions?] | [number[], number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }');\n\n            options = { matrix: options as ConvolutionMatrix };\n\n            if (args[1] !== undefined) options.width = args[1];\n            if (args[2] !== undefined) options.height = args[2];\n        }\n\n        options = { ...ConvolutionFilter.DEFAULT_OPTIONS, ...options };\n\n        const width = options.width ?? 200;\n        const height = options.height ?? 200;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'convolution-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                convolutionUniforms: {\n                    uMatrix: { value: options.matrix, type: 'mat3x3<f32>' },\n                    uTexelSize: { value: { x: 1 / width, y: 1 / height }, type: 'vec2<f32>' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.convolutionUniforms.uniforms;\n\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * An array of values used for matrix transformation, specified as a 9 point Array\n     * @example\n     * const matrix = new Float32Array(9); // 9 elements of value 0\n     * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n     * @default [0,0,0,0,0,0,0,0,0]\n     */\n    get matrix(): ConvolutionMatrix { return this.uniforms.uMatrix; }\n    set matrix(matrix: ConvolutionMatrix)\n    {\n        matrix.forEach((v, i) =>\n        {\n            this.uniforms.uMatrix[i] = v;\n        });\n    }\n\n    /**\n     * Width of the object you are transforming\n     * @default 200\n     */\n    get width(): number { return 1 / this.uniforms.uTexelSize.x; }\n    set width(value: number) { this.uniforms.uTexelSize.x = 1 / value; }\n\n    /**\n     * Height of the object you are transforming\n     * @default 200\n     */\n    get height(): number { return 1 / this.uniforms.uTexelSize.y; }\n    set height(value: number) { this.uniforms.uTexelSize.y = 1 / value; }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './crosshatch.frag';\nimport source from './crosshatch.wgsl';\n\n/**\n * A Cross Hatch effect filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/cross-hatch.png)\n *\n * @class\n * @extends Filter\n */\nexport class CrossHatchFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'cross-hatch-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {},\n        });\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './crt.frag';\nimport source from './crt.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the CRTFilter constructor. */\nexport interface CRTFilterOptions\n{\n    /**\n     * Bend of interlaced lines, higher value means more bend\n     * @default 1\n     */\n    curvature?: number,\n    /**\n     * Width of the interlaced lines\n     * @default 1\n     */\n    lineWidth?: number,\n    /**\n     * Contrast of interlaced lines\n     * @default 0.25\n     */\n    lineContrast?: number,\n    /**\n     * The orientation of the line:\n     *\n     * `true` create vertical lines, `false` creates horizontal lines\n     * @default false\n     */\n    verticalLine?: boolean,\n    /**\n     * For animating interlaced lines\n     * @default 0\n     */\n    time?: number,\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    noise?: number,\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    noiseSize?: number,\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    seed?: number,\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    vignetting?: number,\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    vignettingAlpha?: number,\n    /**\n     * Blur intensity of the vignette\n     * @default 0.3\n     */\n    vignettingBlur?: number,\n}\n\n/**\n * The CRTFilter applies a CRT effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/crt.png)\n *\n * @class\n * @extends Filter\n */\nexport class CRTFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: CRTFilterOptions = {\n        curvature: 1.0,\n        lineWidth: 1.0,\n        lineContrast: 0.25,\n        verticalLine: false,\n        noise: 0.0,\n        noiseSize: 1.0,\n        vignetting: 0.3,\n        vignettingAlpha: 1.0,\n        vignettingBlur: 0.3,\n        time: 0.0,\n        seed: 0.0,\n    };\n\n    public uniforms: {\n        uLine: Float32Array;\n        uNoise: Float32Array;\n        uVignette: Float32Array;\n        uSeed: number;\n        uTime: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    public seed!: number;\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    public time!: number;\n\n    /**\n     * @param options - Options for the CRTFilter constructor.\n     */\n    constructor(options?: CRTFilterOptions)\n    {\n        options = { ...CRTFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'crt-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                crtUniforms: {\n                    uLine: { value: new Float32Array(4), type: 'vec4<f32>' },\n                    uNoise: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uVignette: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uSeed: { value: options.seed, type: 'f32' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.crtUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        this.uniforms.uSeed = this.seed;\n        this.uniforms.uTime = this.time;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Bend of interlaced lines, higher value means more bend\n     * @default 1\n     */\n    get curvature(): number { return this.uniforms.uLine[0]; }\n    set curvature(value: number) { this.uniforms.uLine[0] = value; }\n\n    /**\n     * Width of interlaced lines\n     * @default 1\n     */\n    get lineWidth(): number { return this.uniforms.uLine[1]; }\n    set lineWidth(value: number) { this.uniforms.uLine[1] = value; }\n\n    /**\n     * Contrast of interlaced lines\n     * @default 0.25\n     */\n    get lineContrast(): number { return this.uniforms.uLine[2]; }\n    set lineContrast(value: number) { this.uniforms.uLine[2] = value; }\n\n    /**\n     * The orientation of the line:\n     *\n     * `true` create vertical lines, `false` creates horizontal lines\n     * @default false\n     */\n    get verticalLine(): boolean { return this.uniforms.uLine[3] > 0.5; }\n    set verticalLine(value: boolean) { this.uniforms.uLine[3] = value ? 1 : 0; }\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    get noise(): number { return this.uniforms.uNoise[0]; }\n    set noise(value: number) { this.uniforms.uNoise[0] = value; }\n\n    /**\n     * The size of the noise particles\n     * @default 0\n     */\n    get noiseSize(): number { return this.uniforms.uNoise[1]; }\n    set noiseSize(value: number) { this.uniforms.uNoise[1] = value; }\n\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    get vignetting(): number { return this.uniforms.uVignette[0]; }\n    set vignetting(value: number) { this.uniforms.uVignette[0] = value; }\n\n    /**\n     * Amount of opacity of vignette\n     * @default 1\n     */\n    get vignettingAlpha(): number { return this.uniforms.uVignette[1]; }\n    set vignettingAlpha(value: number) { this.uniforms.uVignette[1] = value; }\n\n    /**\n     * Blur intensity of the vignette\n     * @default 0.3\n     */\n    get vignettingBlur(): number { return this.uniforms.uVignette[2]; }\n    set vignettingBlur(value: number) { this.uniforms.uVignette[2] = value; }\n}\n","import { deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './dot.frag';\nimport source from './dot.wgsl';\n\n/** Options for the DotFilter constructor. */\nexport interface DotFilterOptions\n{\n    /**\n     * The scale of the effect\n     * @default 1\n     */\n    scale?: number;\n    /**\n     * The angle of the effect\n     * @default 5\n     */\n    angle?: number;\n    /**\n     * Whether to rendering it in gray scale\n     * @default true\n     */\n    grayscale?: boolean;\n}\n\n/**\n * This filter applies a dotscreen effect making display objects appear to be made out of\n * black and white halftone dots like an old printer.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/dot.png)\n *\n * {@link https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js Original filter}\n *\n * @class\n * @extends Filter\n */\nexport class DotFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: DotFilterOptions = {\n        scale: 1,\n        angle: 5,\n        grayscale: true\n    };\n\n    /**\n     * @param options - Options for the DotFilter constructor.\n     */\n    constructor(options?: DotFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [scale=1] - The scale of the effect.\n     * @param {number} [angle=5] - The radius of the effect.\n     * @param {boolean} [grayscale=true] - Render as grayscale.\n     */\n    constructor(scale?: number, angle?: number, grayscale?: boolean);\n    /** @ignore */\n    constructor(...args: [DotFilterOptions?] | [number?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'DotFilter constructor params are now options object. See params: { scale, angle, grayscale }');\n\n            options = { scale: options };\n\n            if (args[1] !== undefined) options.angle = args[1];\n            if (args[2] !== undefined) options.grayscale = args[2];\n        }\n\n        options = { ...DotFilter.DEFAULT_OPTIONS, ...options };\n\n        const dotUniforms = {\n            uScale: { value: options.scale, type: 'f32' },\n            uAngle: { value: options.angle, type: 'f32' },\n            uGrayScale: { value: options.grayscale ? 1 : 0, type: 'f32' },\n        };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'dot-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                dotUniforms,\n            },\n        });\n    }\n\n    /**\n     * The scale of the effect.\n     * @default 1\n     */\n    get scale(): number { return this.resources.dotUniforms.uniforms.uScale; }\n    set scale(value: number) { this.resources.dotUniforms.uniforms.uScale = value; }\n\n    /**\n    * The radius of the effect.\n    * @default 5\n    */\n    get angle(): number { return this.resources.dotUniforms.uniforms.uAngle; }\n    set angle(value: number) { this.resources.dotUniforms.uniforms.uAngle = value; }\n\n    /**\n    * Whether to rendering it in gray scale.\n    * @default true\n    */\n    get grayscale(): boolean { return this.resources.dotUniforms.uniforms.uGrayScale === 1; }\n    set grayscale(value: boolean) { this.resources.dotUniforms.uniforms.uGrayScale = value ? 1 : 0; }\n}\n","import {\n    Color,\n    ColorSource,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter';\nimport fragment from './drop-shadow.frag';\nimport source from './drop-shadow.wgsl';\n\n/** Options for the DropShadowFilter constructor. */\nexport interface DropShadowFilterOptions\n{\n    /**\n     * The offset position of the drop-shadow relative to the original image.\n     * @default {x:4,y:4}\n     */\n    offset?: PointData;\n    /**\n     * The color value of shadow.\n     * @example [0.0, 0.0, 0.0] = 0x000000\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * Coefficient for alpha multiplication.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    shadowOnly?: boolean;\n    /**\n     * The strength of the shadow's blur.\n     * @default 2\n     */\n    blur?: number;\n    /**\n     * The quality of the Blur Filter.\n     * @default 4\n     */\n    quality?: number;\n    /**\n     * The kernel size of the blur filter.\n     * @default null\n     */\n    kernels?: number[];\n    /**\n     * The pixelSize of the Kawase Blur filter\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number;\n    /**\n     * The resolution of the Kawase Blur filter\n     * @default 1\n     */\n    resolution?: number;\n}\n\n/**\n * Drop shadow filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/drop-shadow.png)\n * @class\n * @extends Filter\n */\nexport class DropShadowFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: DropShadowFilterOptions = {\n        offset: { x: 4, y: 4 },\n        color: 0x000000,\n        alpha: 0.5,\n        shadowOnly: false,\n        kernels: undefined,\n        blur: 2,\n        quality: 3,\n        pixelSize: { x: 1, y: 1 },\n        resolution: 1,\n    };\n\n    public uniforms: {\n        uAlpha: number;\n        uColor: Float32Array;\n        uOffset: PointData;\n    };\n\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    public shadowOnly = false;\n\n    private _color!: Color;\n    private _blurFilter: KawaseBlurFilter;\n    private _basePass: Filter;\n\n    /**\n     * @param options - Options for the DropShadowFilter constructor.\n     */\n    constructor(options?: DropShadowFilterOptions)\n    {\n        options = { ...DropShadowFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'drop-shadow-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                dropShadowUniforms: {\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uOffset: { value: options.offset, type: 'vec2<f32>' },\n                }\n            },\n            resolution: options.resolution,\n        });\n\n        this.uniforms = this.resources.dropShadowUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n\n        this._blurFilter = new KawaseBlurFilter({\n            strength: options.kernels as [number, number] ?? options.blur,\n            quality: options.kernels ? undefined : options.quality,\n        });\n\n        this._basePass = new Filter({\n            gpuProgram: GpuProgram.from({\n                vertex: {\n                    source: wgslVertex,\n                    entryPoint: 'mainVertex',\n                },\n                fragment: {\n                    source: `\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    `,\n                    entryPoint: 'mainFragment',\n                },\n            }),\n            glProgram: GlProgram.from({\n                vertex,\n                fragment: `\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                `,\n                name: 'drop-shadow-filter',\n            }),\n            resources: {},\n        });\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean,\n    ): void\n    {\n        const renderTarget = TexturePool.getSameSizeTexture(input);\n\n        filterManager.applyFilter(this, input, renderTarget, true);\n        this._blurFilter.apply(filterManager, renderTarget, output, clearMode);\n\n        if (!this.shadowOnly)\n        {\n            filterManager.applyFilter(this._basePass, input, output, false);\n        }\n\n        TexturePool.returnTexture(renderTarget);\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image.\n     * @default [4,4]\n     */\n    public get offset(): PointData { return this.uniforms.uOffset; }\n    public set offset(value: PointData)\n    {\n        this.uniforms.uOffset = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image on the `x` axis\n     * @default 4\n     */\n    get offsetX(): number { return this.offset.x; }\n    set offsetX(value: number)\n    {\n        this.offset.x = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image on the `y` axis\n     * @default 4\n     */\n    get offsetY(): number { return this.offset.y; }\n    set offsetY(value: number)\n    {\n        this.offset.y = value;\n        this._updatePadding();\n    }\n\n    /**\n     * The color value of shadow.\n     * @example [0.0, 0.0, 0.0] = 0x000000\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n     * The strength of the shadow's blur.\n     * @default 2\n     */\n    get blur(): number { return this._blurFilter.strength; }\n    set blur(value: number)\n    {\n        this._blurFilter.strength = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Sets the quality of the Blur Filter\n     * @default 4\n     */\n    get quality(): number { return this._blurFilter.quality; }\n    set quality(value: number)\n    {\n        this._blurFilter.quality = value;\n        this._updatePadding();\n    }\n\n    /** Sets the kernels of the Blur Filter */\n    get kernels(): number[] { return this._blurFilter.kernels; }\n    set kernels(value: number[]) { this._blurFilter.kernels = value; }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter\n     * @default [1,1]\n     */\n    get pixelSize(): PointData\n    {\n        return this._blurFilter.pixelSize as PointData;\n    }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._blurFilter.pixelSize = value;\n    }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter on the `x` axis\n     * @default 1\n     */\n    get pixelSizeX(): number { return this._blurFilter.pixelSizeX; }\n    set pixelSizeX(value: number) { this._blurFilter.pixelSizeX = value; }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter on the `y` axis\n     * @default 1\n     */\n    get pixelSizeY(): number { return this._blurFilter.pixelSizeY; }\n    set pixelSizeY(value: number) { this._blurFilter.pixelSizeY = value; }\n\n    /**\n     * Recalculate the proper padding amount.\n     * @private\n     */\n    private _updatePadding()\n    {\n        const offsetPadding = Math.max(\n            Math.abs(this.offsetX),\n            Math.abs(this.offsetY),\n        );\n\n        this.padding = offsetPadding + (this.blur * 2) + (this.quality * 4);\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './emboss.frag';\nimport source from './emboss.wgsl';\n\n/**\n * An RGB Split Filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/emboss.png)\n *\n * @class\n * @extends Filter\n */\nexport class EmbossFilter extends Filter\n{\n    public uniforms: {\n        uStrength: number;\n    };\n\n    /**\n     * @param {number} [strength=5] - Strength of the emboss.\n     */\n    constructor(strength = 5)\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'emboss-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                embossUniforms: {\n                    uStrength: { value: strength, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.embossUniforms.uniforms;\n    }\n\n    /**\n     * Strength of the emboss\n     * @default 5\n     */\n    get strength(): number { return this.uniforms.uStrength; }\n    set strength(value: number) { this.uniforms.uStrength = value; }\n}\n","import { DEG_TO_RAD, Filter, GlProgram, GpuProgram, ImageSource, Texture } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './glitch.frag';\nimport source from './glitch.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface } from 'pixi.js';\n\nenum FILL_MODES\n    {\n    TRANSPARENT = 0,\n    ORIGINAL = 1,\n    LOOP = 2,\n    CLAMP = 3,\n    MIRROR = 4,\n}\n\n/** Options for the GlitchFilter constructor. */\nexport interface GlitchFilterOptions\n{\n    /**\n     * The count of glitch slices.\n     * @default 5\n     */\n    slices?: number;\n    /**\n     * The maximum offset amount of slices.\n     * @default 100\n     */\n    offset?: number;\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    direction?: number;\n    /**\n     * The fill mode of the space after the offset.\n     * @default FILL_MODES.TRANSPARENT\n     */\n    fillMode?: number;\n    /**\n     * A seed value for randomizing glitch effect.\n     * @default 0\n     */\n    seed?: number;\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     * @default false\n     */\n    average?: boolean;\n    /**\n     * Minimum size of slices as a portion of the `sampleSize`\n     * @default 8\n     */\n    minSize?: number;\n    /**\n     * Height of the displacement map canvas.\n     * @default 512\n     */\n    sampleSize?: number;\n    /**\n     * Red channel offset.\n     * @default {x:0,y:0}\n     */\n    red?: PointData | number[];\n    /**\n     * Green channel offset.\n     * @default {x:0,y:0}\n     */\n    green?: PointData | number[];\n    /**\n     * Blue offset.\n     * @default {x:0,y:0}\n     */\n    blue?: PointData | number[];\n}\n\n/**\n * The GlitchFilter applies a glitch effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/glitch.png)\n *\n * @class\n * @extends Filter\n */\nexport class GlitchFilter extends Filter\n{\n    /** Default constructor options. */\n    public static readonly defaults: GlitchFilterOptions = {\n        slices: 5,\n        offset: 100,\n        direction: 0,\n        fillMode: 0,\n        average: false,\n        seed: 0,\n        red: { x: 0, y: 0 },\n        green: { x: 0, y: 0 },\n        blue: { x: 0, y: 0 },\n        minSize: 8,\n        sampleSize: 512,\n    };\n\n    public uniforms: {\n        uSeed: number\n        uDimensions: Float32Array,\n        uAspect: number,\n        uFillMode: number,\n        uOffset: number,\n        uDirection: number,\n        uRed: PointData,\n        uGreen: PointData,\n        uBlue: PointData,\n    };\n\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n    public average = false;\n\n    /** Minimum size of slices as a portion of the `sampleSize` */\n    public minSize = 8;\n\n    /** Height of the displacement map canvas. */\n    public sampleSize = 512;\n\n    /** Internally generated canvas. */\n    private _canvas: HTMLCanvasElement;\n\n    /**\n     * The displacement map is used to generate the bands.\n     * If using your own texture, `slices` will be ignored.\n     *\n     * @member {Texture}\n     * @readonly\n     */\n    public texture: Texture;\n\n    /** Internal number of slices */\n    private _slices = 0;\n\n    private _sizes: Float32Array = new Float32Array(1);\n    private _offsets: Float32Array = new Float32Array(1);\n\n    /**\n     * @param options - Options for the GlitchFilter constructor.\n     */\n    constructor(options?: GlitchFilterOptions)\n    {\n        options = { ...GlitchFilter.defaults, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'glitch-filter',\n        });\n\n        const canvas = document.createElement('canvas');\n\n        canvas.width = 4;\n        canvas.height = options.sampleSize ?? 512;\n\n        const texture = new Texture({\n            source: new ImageSource({ resource: canvas })\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                glitchUniforms: {\n                    uSeed: { value: options?.seed ?? 0, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uAspect: { value: 1, type: 'f32' },\n                    uFillMode: { value: options?.fillMode ?? 0, type: 'f32' },\n                    uOffset: { value: options?.offset ?? 100, type: 'f32' },\n                    uDirection: { value: options?.direction ?? 0, type: 'f32' },\n                    uRed: { value: options.red, type: 'vec2<f32>' },\n                    uGreen: { value: options.green, type: 'vec2<f32>' },\n                    uBlue: { value: options.blue, type: 'vec2<f32>' },\n                },\n                uDisplacementMap: texture.source,\n                uDisplacementSampler: texture.source.style,\n            },\n        });\n\n        this.uniforms = this.resources.glitchUniforms.uniforms;\n\n        this._canvas = canvas;\n        this.texture = texture;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in Filter\n     * @private\n     */\n    apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const { width, height } = input.frame;\n\n        this.uniforms.uDimensions[0] = width;\n        this.uniforms.uDimensions[1] = height;\n        this.uniforms.uAspect = height / width;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Randomize the slices size (heights).\n     *\n     * @private\n     */\n    private _randomizeSizes()\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n        const size = this.sampleSize;\n        const min = Math.min(this.minSize / size, 0.9 / this._slices);\n\n        if (this.average)\n        {\n            const count = this._slices;\n            let rest = 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                const averageWidth = rest / (count - i);\n                const w = Math.max(averageWidth * (1 - (Math.random() * 0.6)), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n        else\n        {\n            let rest = 1;\n            const ratio = Math.sqrt(1 / this._slices);\n\n            for (let i = 0; i < last; i++)\n            {\n                const w = Math.max(ratio * rest * Math.random(), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n\n        this.shuffle();\n    }\n\n    /**\n     * Shuffle the sizes of the slices, advanced usage.\n     */\n    shuffle(): void\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n\n        // shuffle\n        for (let i = last; i > 0; i--)\n        {\n            const rand = (Math.random() * i) >> 0;\n            const temp = arr[i];\n\n            arr[i] = arr[rand];\n            arr[rand] = temp;\n        }\n    }\n\n    /**\n     * Randomize the values for offset from -1 to 1\n     *\n     * @private\n     */\n    private _randomizeOffsets(): void\n    {\n        for (let i = 0; i < this._slices; i++)\n        {\n            this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n        }\n    }\n\n    /**\n     * Regenerating random size, offsets for slices.\n     */\n    refresh(): void\n    {\n        this._randomizeSizes();\n        this._randomizeOffsets();\n        this.redraw();\n    }\n\n    /**\n     * Redraw displacement bitmap texture, advanced usage.\n     */\n    redraw(): void\n    {\n        const size = this.sampleSize;\n        const texture = this.texture;\n        const ctx = this._canvas.getContext('2d') as CanvasRenderingContext2D;\n\n        ctx.clearRect(0, 0, 8, size);\n\n        let offset;\n        let y = 0;\n\n        for (let i = 0; i < this._slices; i++)\n        {\n            offset = Math.floor(this._offsets[i] * 256);\n            const height = this._sizes[i] * size;\n            const red = offset > 0 ? offset : 0;\n            const green = offset < 0 ? -offset : 0;\n\n            ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;\n            ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n            y += height;\n        }\n\n        texture.source.update();\n    }\n\n    /**\n     * Manually custom slices size (height) of displacement bitmap\n     *\n     * @member {number[]|Float32Array}\n     */\n    set sizes(sizes: Float32Array)\n    {\n        const len = Math.min(this._slices, sizes.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._sizes[i] = sizes[i];\n        }\n    }\n    get sizes(): Float32Array\n    {\n        return this._sizes;\n    }\n\n    /**\n     * Manually set custom slices offset of displacement bitmap, this is\n     * a collection of values from -1 to 1. To change the max offset value\n     * set `offset`.\n     *\n     * @member {number[]|Float32Array}\n     */\n    set offsets(offsets: Float32Array)\n    {\n        const len = Math.min(this._slices, offsets.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._offsets[i] = offsets[i];\n        }\n    }\n    get offsets(): Float32Array { return this._offsets; }\n\n    /**\n     * The count of slices.\n     * @default 5\n     */\n    get slices(): number { return this._slices; }\n    set slices(value: number)\n    {\n        if (this._slices === value) return;\n        this._slices = value;\n        this._sizes = new Float32Array(value);\n        this._offsets = new Float32Array(value);\n        this.refresh();\n    }\n\n    /**\n     * The maximum offset amount of slices.\n     * @default 100\n     */\n    get offset(): number { return this.uniforms.uOffset; }\n    set offset(value: number) { this.uniforms.uOffset = value; }\n\n    /**\n     * A seed value for randomizing glitch effect.\n     * @default 0\n     */\n    get seed(): number { return this.uniforms.uSeed; }\n    set seed(value: number) { this.uniforms.uSeed = value; }\n\n    /**\n     * The fill mode of the space after the offset.\n     * @default FILL_MODES.TRANSPARENT\n     */\n    get fillMode(): FILL_MODES { return this.uniforms.uFillMode; }\n    set fillMode(value: FILL_MODES) { this.uniforms.uFillMode = value; }\n\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    get direction(): number { return this.uniforms.uDirection / DEG_TO_RAD; }\n    set direction(value: number) { this.uniforms.uDirection = value * DEG_TO_RAD; }\n\n    /**\n     * Red channel offset.\n     * @default {x:0,y:0}\n     */\n    get red(): PointData { return this.uniforms.uRed; }\n    set red(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uRed = value;\n    }\n\n    /**\n     * Green channel offset.\n     * @default {x:0,y:0}\n     */\n    get green(): PointData { return this.uniforms.uGreen; }\n    set green(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uGreen = value;\n    }\n\n    /**\n     * Blue offset.\n     * @default {x:0,y:0}\n     */\n    get blue(): PointData { return this.uniforms.uBlue; }\n    set blue(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uBlue = value;\n    }\n\n    /**\n     * Removes all references\n     */\n    destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture\n        = this._canvas\n        = this.red\n        = this.green\n        = this.blue\n        = this._sizes\n        = this._offsets = null as any;\n    }\n}\n","import { Color, ColorSource, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './glow.frag';\nimport source from './glow.wgsl';\n\n/**\n * Options for the GlowFilter constructor.\n */\nexport interface GlowFilterOptions\n{\n    /**\n     * The distance of the glow\n     * @default 10\n     */\n    distance?: number;\n    /**\n     * The strength of the glow outward from the edge of the sprite\n     * @default 4\n     */\n    outerStrength?: number;\n    /**\n     * The strength of the glow inward from the edge of the sprite\n     * @default 0\n     */\n    innerStrength?: number;\n    /**\n     * The color of the glow\n     * @default 0xffffff\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the glow\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n     * @default 0.1\n     */\n    quality?: number;\n    /**\n     * Toggle to hide the contents and only show glow\n     * @default false\n     */\n    knockout?: boolean;\n}\n\n/**\n * GlowFilter, originally by mishaa\n * [codepen]{@link http://codepen.io/mishaa/pen/raKzrm}.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/glow.png)\n * @class\n *\n * @extends Filter\n *\n * @example\n *  someSprite.filters = [\n *      new GlowFilter({ distance: 15, outerStrength: 2 })\n *  ];\n */\nexport class GlowFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: GlowFilterOptions = {\n        distance: 10,\n        outerStrength: 4,\n        innerStrength: 0,\n        color: 0xffffff,\n        alpha: 1,\n        quality: 0.1,\n        knockout: false,\n    };\n\n    public uniforms: {\n        uDistance: number;\n        uStrength: Float32Array;\n        uColor: Float32Array;\n        uAlpha: number;\n        uQuality: number;\n        uKnockout: number;\n    };\n\n    private _color!: Color;\n\n    /**\n     * @param options - Options for the GlowFilter constructor.\n     */\n    constructor(options?: GlowFilterOptions)\n    {\n        options = { ...GlowFilter.DEFAULT_OPTIONS, ...options };\n\n        const distance = options.distance ?? 10;\n        const quality = options.quality ?? 0.1;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        // Altering uDistance and uQuality won't have any affect on WebGL\n        // since we hard-assign them during creation to allow\n        // for the values to be used in GLSL loops\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment\n                .replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`)\n                .replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),\n            name: 'glow-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                glowUniforms: {\n                    uDistance: { value: distance, type: 'f32' },\n                    uStrength: { value: [options.innerStrength, options.outerStrength], type: 'vec2<f32>' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uQuality: { value: quality, type: 'f32' },\n                    uKnockout: { value: (options?.knockout ?? false) ? 1 : 0, type: 'f32' },\n                }\n            },\n            padding: distance,\n        });\n\n        this.uniforms = this.resources.glowUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0xffffff;\n    }\n\n    /**\n     * Only draw the glow, not the texture itself\n     * @default false\n     */\n    get distance(): number { return this.uniforms.uDistance; }\n    set distance(value: number) { this.uniforms.uDistance = this.padding = value; }\n\n    /**\n    * The strength of the glow inward from the edge of the sprite.\n    * @default 0\n    */\n    get innerStrength(): number { return this.uniforms.uStrength[0]; }\n    set innerStrength(value: number) { this.uniforms.uStrength[0] = value; }\n\n    /**\n    * The strength of the glow outward from the edge of the sprite.\n    * @default 4\n    */\n    get outerStrength(): number { return this.uniforms.uStrength[1]; }\n    set outerStrength(value: number) { this.uniforms.uStrength[1] = value; }\n\n    /**\n    * The color of the glow.\n    * @default 0xFFFFFF\n    */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n    * The alpha of the glow\n    * @default 1\n    */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n    * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n    * @default 0.1\n    */\n    get quality(): number { return this.uniforms.uQuality; }\n    set quality(value: number) { this.uniforms.uQuality = value; }\n\n    /**\n    * Only draw the glow, not the texture itself\n    * @default false\n    */\n    get knockout(): boolean { return this.uniforms.uKnockout === 1; }\n    set knockout(value: boolean) { this.uniforms.uKnockout = value ? 1 : 0; }\n}\n","import { DEG_TO_RAD, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './god-ray.frag';\nimport source from './god-ray.wgsl';\nimport perlin from './perlin.frag';\nimport sourcePerlin from './perlin.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the GodrayFilter constructor. */\nexport interface GodrayFilterOptions\n{\n    /**\n     * The angle/light-source of the rays in degrees. For instance,\n     * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays.\n     * @default 30\n     */\n    angle?: number;\n    /**\n     * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n     * @default true\n     */\n    parallel?: boolean;\n    /**\n     * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[];\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect.\n     * @default 0.5\n     */\n    gain?: number;\n    /**\n     * The density of the fractal noise\n     * @default 2.5\n     */\n    lacunarity?: number;\n    /**\n     * The current time position\n     * @default 0\n     */\n    time?: number;\n    /**\n     * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * GordayFilter, {@link https://codepen.io/alaingalvan originally} by Alain Galvan\n *\n *\n *\n * ![original](../screenshots/original.png)![filter](../screenshots/godray.gif)\n * @class\n * @extends Filter\n *\n * @example\n *  displayObject.filters = [new GodrayFilter()];\n */\nexport class GodrayFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: GodrayFilterOptions = {\n        angle: 30,\n        gain: 0.5,\n        lacunarity: 2.5,\n        parallel: true,\n        time: 0,\n        center: { x: 0, y: 0 },\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uLight: Float32Array;\n        uParallel: number;\n        uAspect: number;\n        uTime: number;\n        uRay: Float32Array;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * The current time position\n     * @default 0\n     */\n    public time = 0;\n\n    private _angleLight: [number, number] = [0, 0];\n    private _angle = 0;\n    private _center!: PointData;\n\n    /**\n     * @param options - Options for the GodrayFilter constructor.\n     */\n    constructor(options?: GodrayFilterOptions)\n    {\n        options = { ...GodrayFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: source.replace('${PERLIN}', sourcePerlin),\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace('${PERLIN}', perlin),\n            name: 'god-ray-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                godrayUniforms: {\n                    uLight: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uParallel: { value: 0, type: 'f32' },\n                    uAspect: { value: 0, type: 'f32' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uRay: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.godrayUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in Filter\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const width = input.frame.width;\n        const height = input.frame.height;\n\n        this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x;\n        this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y;\n        this.uniforms.uDimensions[0] = width;\n        this.uniforms.uDimensions[1] = height;\n        this.uniforms.uAspect = height / width;\n        this.uniforms.uTime = this.time;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The angle/light-source of the rays in degrees. For instance,\n     * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays\n     * @default 30\n     */\n    get angle(): number { return this._angle; }\n    set angle(value: number)\n    {\n        this._angle = value;\n\n        const radians = value * DEG_TO_RAD;\n\n        this._angleLight[0] = Math.cos(radians);\n        this._angleLight[1] = Math.sin(radians);\n    }\n\n    /**\n     * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n     * @default true\n     */\n    get parallel(): boolean { return this.uniforms.uParallel > 0.5; }\n    set parallel(value: boolean) { this.uniforms.uParallel = value ? 1 : 0; }\n\n    /**\n     * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n     * @default {x:0,y:0}\n     */\n    get center(): PointData { return this._center; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._center = value;\n    }\n\n    /**\n     * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.\n     * @default 0\n     */\n    get centerX(): number { return this.center.x; }\n    set centerX(value: number) { this.center.x = value; }\n\n    /**\n     * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.\n     * @default 0\n     */\n    get centerY(): number { return this.center.y; }\n    set centerY(value: number) { this.center.y = value; }\n\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect\n     * @default 0.5\n     */\n    get gain(): number { return this.uniforms.uRay[0]; }\n    set gain(value: number) { this.uniforms.uRay[0] = value; }\n\n    /**\n     * The density of the fractal noise.\n     * A higher amount produces more rays and a smaller amount produces fewer waves\n     * @default 2.5\n     */\n    get lacunarity(): number { return this.uniforms.uRay[1]; }\n    set lacunarity(value: number) { this.uniforms.uRay[1] = value; }\n\n    /**\n     * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uRay[2]; }\n    set alpha(value: number) { this.uniforms.uRay[2] = value; }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './grayscale.frag';\nimport source from './grayscale.wgsl';\n\n/**\n * This filter applies a grayscale effect.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/grayscale.png)\n *\n * @class\n * @extends Filter\n */\nexport class GrayscaleFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'grayscale-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {},\n        });\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './hsladjustment.frag';\nimport source from './hsladjustment.wgsl';\n\n/**\n * Options for the HslAdjustmentFilter constructor.\n */\nexport interface HslAdjustmentFilterOptions\n{\n    /**\n     * The amount of hue in degrees (-180 to 180)\n     * @default 0\n     */\n    hue: number;\n    /**\n     * The amount of color saturation (-1 to 1)\n     * @default 0\n     */\n    saturation: number;\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    lightness: number;\n    /**\n     * Whether to colorize the image\n     * @default false\n     */\n    colorize: boolean;\n    /**\n     * The amount of alpha (0 to 1)\n     * @default 1\n     */\n    alpha: number;\n}\n\n/**\n * ![original](../screenshots/original.png)![filter](../screenshots/hsl-adjustment.png)\n *\n * This WebGPU filter has been ported from the WebGL renderer that was originally created by Viktor Persson (@vikpe)\n *\n * @class\n * @extends Filter\n */\nexport class HslAdjustmentFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: HslAdjustmentFilterOptions = {\n        hue: 0,\n        saturation: 0,\n        lightness: 0,\n        colorize: false,\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uHsl: Float32Array;\n        uColorize: number;\n        uAlpha: number;\n    };\n\n    private _hue!: number;\n\n    /**\n     * @param options - Options for the HslAdjustmentFilter constructor.\n     */\n    constructor(options?: HslAdjustmentFilterOptions)\n    {\n        options = { ...HslAdjustmentFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'hsl-adjustment-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                hslUniforms: {\n                    uHsl: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uColorize: { value: options.colorize ? 1 : 0, type: 'f32' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.hslUniforms.uniforms;\n        Object.assign(this, options);\n    }\n\n    /**\n     * The amount of hue in degrees (-180 to 180)\n     * @default 0\n     */\n    get hue(): number { return this._hue; }\n    set hue(value: number)\n    {\n        this._hue = value;\n        this.uniforms.uHsl[0] = value * (Math.PI / 180);\n    }\n\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    get saturation(): number { return this.uniforms.uHsl[1]; }\n    set saturation(value: number) { this.uniforms.uHsl[1] = value; }\n\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    get lightness(): number { return this.uniforms.uHsl[2]; }\n    set lightness(value: number) { this.uniforms.uHsl[2] = value; }\n\n    /**\n     * Whether to colorize the image\n     * @default false\n     */\n    get colorize(): boolean { return this.uniforms.uColorize === 1; }\n    set colorize(value: boolean) { this.uniforms.uColorize = value ? 1 : 0; }\n\n    /**\n     * The amount of alpha (0 to 1)\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n}\n","/* eslint-disable max-len */\nimport { deprecation, Filter, GlProgram, GpuProgram, ObservablePoint, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './motion-blur.frag';\nimport source from './motion-blur.wgsl';\n\n/** Options for the MotionBlurFilter constructor. */\nexport interface MotionBlurFilterOptions\n{\n    /**\n     * Sets the velocity of the motion for blur effect\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    velocity?: PointData | number[];\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 5\n     * @default 5\n     */\n    kernelSize?: number;\n    /**\n     * The offset of the blur filter\n     * @default 0\n     */\n    offset?: number;\n}\n\n/**\n * The MotionBlurFilter applies a Motion blur to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/motion-blur.png)\n *\n * @class\n * @extends Filter\n */\nexport class MotionBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: MotionBlurFilterOptions = {\n        velocity: { x: 0, y: 0 },\n        kernelSize: 5,\n        offset: 0,\n    };\n\n    public uniforms: {\n        uVelocity: PointData;\n        uKernelSize: number;\n        uOffset: number;\n    };\n\n    private _kernelSize!: number;\n\n    /**\n     * @param options - Options for the MotionBlurFilter constructor.\n     */\n    constructor(options?: MotionBlurFilterOptions);\n    /**\n     * @deprecated since 8.0.0\n     *\n     * @param {PIXI.ObservablePoint|PIXI.PointData|number[]} [velocity=[0, 0]] - Sets the velocity of the motion for blur effect.\n     * @param {number} [kernelSize=5] - The kernelSize of the blur filter. Must be odd number >= 5\n     * @param {number} [offset=0] - The offset of the blur filter.\n     */\n    constructor(velocity?: number[] | PointData | ObservablePoint, kernelSize?: number, offset?: number);\n    /** @ignore */\n    constructor(...args: [MotionBlurFilterOptions?] | [(number[] | PointData | ObservablePoint)?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options) || ('x' in options && 'y' in options) || options instanceof ObservablePoint)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }');\n\n            const x = 'x' in options ? options.x : options[0];\n            const y = 'y' in options ? options.y : options[1];\n\n            options = { velocity: { x, y } };\n\n            if (args[1] !== undefined) options.kernelSize = args[1];\n            if (args[2] !== undefined) options.offset = args[2];\n        }\n\n        options = { ...MotionBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'motion-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                motionBlurUniforms: {\n                    uVelocity: { value: options.velocity, type: 'vec2<f32>' },\n                    uKernelSize: { value: Math.trunc(options.kernelSize ?? 5), type: 'i32' },\n                    uOffset: { value: options.offset, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.motionBlurUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    get velocity(): PointData { return this.uniforms.uVelocity; }\n    set velocity(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uVelocity = value;\n        this._updateDirty();\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get velocityX(): number { return this.velocity.x; }\n    set velocityX(value: number)\n    {\n        this.velocity.x = value;\n        this._updateDirty();\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get velocityY(): number { return this.velocity.y; }\n    set velocityY(value: number)\n    {\n        this.velocity.y = value;\n        this._updateDirty();\n    }\n\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 5\n     * @default 5\n     */\n    get kernelSize(): number { return this._kernelSize; }\n    set kernelSize(value: number)\n    {\n        this._kernelSize = value;\n        this._updateDirty();\n    }\n\n    /**\n     * The offset of the blur filter\n     * @default 0\n     */\n    get offset(): number { return this.uniforms.uOffset; }\n    set offset(value: number) { this.uniforms.uOffset = value; }\n\n    private _updateDirty()\n    {\n        // The padding will be increased as the velocity and intern the blur size is changed\n        this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1;\n        this.uniforms.uKernelSize = (this.velocityX !== 0 || this.velocityY !== 0) ? this._kernelSize : 0;\n    }\n}\n","import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './multi-color-replace.frag';\nimport source from './multi-color-replace.wgsl';\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the MultiColorReplaceFilter constructor. */\nexport interface MultiColorReplaceFilterOptions\n{\n    /**\n     * The collection of replacement items. Each item is color-pair\n     * (an array length is 2). In the pair, the first value is original color , the second value is target color\n     *\n     * _If you wish to change individual elements on the replacement array after instantiation,\n     * use the `refresh` function to update the uniforms once you've made the changes_\n     */\n    replacements: Array<[ColorSource, ColorSource]>;\n    /**\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.05\n     */\n    tolerance?: number\n    /**\n     * The maximum number of replacements filter is able to use.\n     * Because the fragment is only compiled once, this cannot be changed after construction.\n     * If omitted, the default value is the length of `replacements`\n     */\n    maxColors?: number;\n}\n\n/**\n * Filter for replacing a color with another color. Similar to ColorReplaceFilter, but support multiple\n * colors.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/multi-color-replace.png)\n * @class\n * @extends Filter\n *\n * @example\n *  // replaces pure red with pure blue, and replaces pure green with pure white\n *  someSprite.filters = [new MultiColorReplaceFilter({\n *    replacements: [\n *      [0xFF0000, 0x0000FF],\n *      [0x00FF00, 0xFFFFFF]\n *    ],\n *    tolerance: 0.001\n *  })];\n *\n *  You also could use [R, G, B] as the color\n *  someOtherSprite.filters = [new MultiColorReplaceFilter({\n *    replacements: [\n *      [ [1,0,0], [0,0,1] ],\n *      [ [0,1,0], [1,1,1] ]\n *    ],\n *    tolerance: 0.001\n *  })];\n *\n */\nexport class MultiColorReplaceFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: MultiColorReplaceFilterOptions = {\n        replacements: [[0xff0000, 0x0000ff]],\n        tolerance: 0.05,\n        maxColors: undefined,\n    };\n\n    public uniforms: {\n        uOriginalColors: Float32Array;\n        uTargetColors: Float32Array;\n        uTolerance: number;\n    };\n\n    private _replacements: Array<[ColorSource, ColorSource]> = [];\n    private _maxColors: number;\n\n    /**\n     * @param options - Options for the MultiColorReplaceFilter constructor.\n     */\n    constructor(options?: MultiColorReplaceFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {Array<Array>} replacements - The collection of replacement items. Each item is color-pair\n     *        (an array length is 2). In the pair, the first value is original color , the second value\n     *        is target color.\n     * @param {number} [epsilon=0.05] - Tolerance of the floating-point comparison between colors\n     *        (lower = more exact, higher = more inclusive)\n     * @param {number} [maxColors] - The maximum number of replacements filter is able to use. Because the\n     *        fragment is only compiled once, this cannot be changed after construction.\n     *        If omitted, the default value is the length of `replacements`.\n     */\n    constructor(replacements: Array<[DeprecatedColor, DeprecatedColor]>, epsilon?: number, maxColors?: number);\n    /** @ignore */\n    constructor(...args: [MultiColorReplaceFilterOptions?] | [Array<[DeprecatedColor, DeprecatedColor]>, number?, number?])\n    {\n        let options = args[0] ?? {} as MultiColorReplaceFilterOptions;\n\n        if (Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }');\n\n            options = { replacements: options };\n\n            if (args[1]) options.tolerance = args[1];\n            if (args[2]) options.maxColors = args[2];\n        }\n\n        options = { ...MultiColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n\n        const maxColors = options.maxColors ?? options.replacements.length;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: source.replace(/\\$\\{MAX_COLORS\\}/g, (maxColors).toFixed(0)),\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace(/\\$\\{MAX_COLORS\\}/g, (maxColors).toFixed(0)),\n            name: 'multi-color-replace-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                multiColorReplaceUniforms: {\n                    uOriginalColors: {\n                        value: new Float32Array(3 * maxColors),\n                        type: 'vec3<f32>',\n                        size: maxColors\n                    },\n                    uTargetColors: {\n                        value: new Float32Array(3 * maxColors),\n                        type: 'vec3<f32>',\n                        size: maxColors\n                    },\n                    uTolerance: { value: options.tolerance, type: 'f32' },\n                }\n            },\n        });\n\n        this._maxColors = maxColors;\n\n        this.uniforms = this.resources.multiColorReplaceUniforms.uniforms;\n\n        this.replacements = options.replacements;\n    }\n\n    /**\n     * The collection of replacement items. Each item is color-pair\n     * (an array length is 2). In the pair, the first value is original color , the second value is target color\n     */\n    set replacements(replacements: Array<[ColorSource, ColorSource]>)\n    {\n        const originals = this.uniforms.uOriginalColors;\n        const targets = this.uniforms.uTargetColors;\n        const colorCount = replacements.length;\n        const color = new Color();\n\n        if (colorCount > this._maxColors)\n        {\n            throw new Error(`Length of replacements (${colorCount}) exceeds the maximum colors length (${this._maxColors})`);\n        }\n\n        // Fill with negative values\n        originals[colorCount * 3] = -1;\n\n        let r;\n        let g;\n        let b;\n\n        for (let i = 0; i < colorCount; i++)\n        {\n            const pair = replacements[i];\n\n            // for original colors\n            color.setValue(pair[0]);\n\n            [r, g, b] = color.toArray();\n\n            originals[i * 3] = r;\n            originals[(i * 3) + 1] = g;\n            originals[(i * 3) + 2] = b;\n\n            // for target colors\n            color.setValue(pair[1]);\n\n            [r, g, b] = color.toArray();\n\n            targets[i * 3] = r;\n            targets[(i * 3) + 1] = g;\n            targets[(i * 3) + 2] = b;\n        }\n\n        this._replacements = replacements;\n    }\n\n    get replacements(): Array<[ColorSource, ColorSource]>\n    {\n        return this._replacements;\n    }\n\n    /**\n      * Should be called after changing any of the contents of the replacements.\n      * This is a convenience method for resetting the `replacements`.\n      * @todo implement nested proxy to remove the need for this function\n      */\n    refresh(): void\n    {\n        this.replacements = this._replacements;\n    }\n\n    /**\n      * The maximum number of color replacements supported by this filter. Can be changed\n      * _only_ during construction.\n      * @readonly\n      */\n    get maxColors(): number { return this._maxColors; }\n\n    /**\n      * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n      * @default 0.05\n      */\n    get tolerance(): number { return this.uniforms.uTolerance; }\n    set tolerance(value: number) { this.uniforms.uTolerance = value; }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.05\n     */\n    set epsilon(value: number)\n    {\n        // eslint-disable-next-line max-len\n        deprecation('6.0.0', 'MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead');\n        this.tolerance = value;\n    }\n    get epsilon(): number\n    {\n        // eslint-disable-next-line max-len\n        deprecation('6.0.0', 'MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead');\n\n        return this.tolerance;\n    }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './old-film.frag';\nimport source from './old-film.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the OldFilmFilter constructor. */\nexport interface OldFilmFilterOptions\n{\n    /**\n     * The amount of saturation of sepia effect,\n     * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n     * @default 0.3\n     */\n    sepia?: number;\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    noise?: number;\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    noiseSize?: number;\n    /**\n     * How often scratches appear\n     * @default 0.5\n     */\n    scratch?: number;\n    /**\n     * The density of the number of scratches\n     * @default 0.3\n     */\n    scratchDensity?: number;\n    /**\n     * The width of the scratches\n     * @default 1\n     */\n    scratchWidth?: number;\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    vignetting?: number;\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    vignettingAlpha?: number;\n    /**\n     * Blur intensity of the vignette\n     * @default 1\n     */\n    vignettingBlur?: number;\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    seed?: number;\n}\n\n/**\n * The OldFilmFilter applies a Old film effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/old-film.gif)\n *\n * @class\n * @extends Filter\n */\nexport class OldFilmFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: OldFilmFilterOptions = {\n        sepia: 0.3,\n        noise: 0.3,\n        noiseSize: 1,\n        scratch: 0.5,\n        scratchDensity: 0.3,\n        scratchWidth: 1,\n        vignetting: 0.3,\n        vignettingAlpha: 1,\n        vignettingBlur: 0.3,\n        seed: 0\n    };\n\n    public uniforms: {\n        uSepia: number;\n        uNoise: Float32Array;\n        uScratch: Float32Array;\n        uVignetting: Float32Array;\n        uSeed: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    public seed!: number;\n\n    /**\n     * @param options - Options for the OldFilmFilter constructor.\n     */\n    constructor(options?: OldFilmFilterOptions)\n    {\n        options = { ...OldFilmFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'old-film-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                oldFilmUniforms: {\n                    uSepia: { value: options.sepia, type: 'f32' },\n                    uNoise: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uScratch: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uVignetting: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uSeed: { value: options.seed, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.oldFilmUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n        this.uniforms.uSeed = this.seed;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The amount of saturation of sepia effect,\n     * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n     * @default 0.3\n     */\n    get sepia(): number { return this.uniforms.uSepia; }\n    set sepia(value: number) { this.uniforms.uSepia = value; }\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    get noise(): number { return this.uniforms.uNoise[0]; }\n    set noise(value: number) { this.uniforms.uNoise[0] = value; }\n\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    get noiseSize(): number { return this.uniforms.uNoise[1]; }\n    set noiseSize(value: number) { this.uniforms.uNoise[1] = value; }\n\n    /**\n     * How often scratches appear\n     * @default 0.5\n     */\n    get scratch(): number { return this.uniforms.uScratch[0]; }\n    set scratch(value: number) { this.uniforms.uScratch[0] = value; }\n\n    /**\n     * The density of the number of scratches\n     * @default 0.3\n     */\n    get scratchDensity(): number { return this.uniforms.uScratch[1]; }\n    set scratchDensity(value: number) { this.uniforms.uScratch[1] = value; }\n\n    /**\n     * The width of the scratches\n     * @default 1\n     */\n    get scratchWidth(): number { return this.uniforms.uScratch[2]; }\n    set scratchWidth(value: number) { this.uniforms.uScratch[2] = value; }\n\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    get vignetting(): number { return this.uniforms.uVignetting[0]; }\n    set vignetting(value: number) { this.uniforms.uVignetting[0] = value; }\n\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    get vignettingAlpha(): number { return this.uniforms.uVignetting[1]; }\n    set vignettingAlpha(value: number) { this.uniforms.uVignetting[1] = value; }\n\n    /**\n     * Blur intensity of the vignette\n     * @default 1\n     */\n    get vignettingBlur(): number { return this.uniforms.uVignetting[2]; }\n    set vignettingBlur(value: number) { this.uniforms.uVignetting[2] = value; }\n}\n","import { Color, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './outline.frag';\nimport source from './outline.wgsl';\n\nimport type { ColorSource, FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the OutlineFilter constructor. */\nexport interface OutlineFilterOptions\n{\n    /**\n     * The thickness of the outline\n     * @default 1\n     */\n    thickness?: number;\n    /**\n     * The color of the outline\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the outline\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * The quality of the outline from `0` to `1`.\n     * Using a higher quality setting will result in more accuracy but slower performance\n     * @default 0.1\n     */\n    quality?: number;\n    /**\n     * Whether to only render outline, not the contents.\n     * @default false\n     */\n    knockout?: boolean;\n}\n\n/**\n * OutlineFilter, originally by mishaa\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n * http://codepen.io/mishaa/pen/emGNRB<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/outline.png)\n *\n * @class\n * @extends Filter *\n * @example\n *  someSprite.filters = [new OutlineFilter(2, 0x99ff99)];\n */\nexport class OutlineFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: OutlineFilterOptions = {\n        thickness: 1,\n        color: 0x000000,\n        alpha: 1,\n        quality: 0.1,\n        knockout: false,\n    };\n\n    /** The minimum number of samples for rendering outline. */\n    public static MIN_SAMPLES = 1;\n\n    /** The maximum number of samples for rendering outline. */\n    public static MAX_SAMPLES = 100;\n\n    public uniforms: {\n        uThickness: Float32Array,\n        uColor: Float32Array,\n        uAlpha: number;\n        uAngleStep: number,\n        uKnockout: number,\n    };\n\n    private _thickness!: number;\n    private _quality!: number;\n    private _color!: Color;\n\n    /**\n     * @param options - Options for the OutlineFilter constructor.\n     */\n    constructor(options?: OutlineFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [thickness=1] - The tickness of the outline. Make it 2 times more for resolution 2\n     * @param {number} [color=0x000000] - The color of the outline.\n     * @param {number} [quality=0.1] - The quality of the outline from `0` to `1`, using a higher quality\n     *        setting will result in slower performance and more accuracy.\n     * @param {number} [alpha=1.0] - The alpha of the outline.\n     * @param {boolean} [knockout=false] - Only render outline, not the contents.\n     */\n    constructor(thickness?: number, color?: number, quality?: number, alpha?: number, knockout?: boolean);\n    /** @ignore */\n    constructor(...args: [OutlineFilterOptions?] | [number?, number?, number?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }');\n\n            options = { thickness: options };\n\n            if (args[1] !== undefined) options.color = args[1];\n            if (args[2] !== undefined) options.quality = args[2];\n            if (args[3] !== undefined) options.alpha = args[3];\n            if (args[4] !== undefined) options.knockout = args[4];\n        }\n\n        options = { ...OutlineFilter.DEFAULT_OPTIONS, ...options };\n\n        const quality = options.quality ?? 0.1;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace(/\\$\\{ANGLE_STEP\\}/, OutlineFilter.getAngleStep(quality).toFixed(7)),\n            name: 'outline-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                outlineUniforms: {\n                    uThickness: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uAngleStep: { value: 0, type: 'f32' },\n                    uKnockout: { value: options.knockout ? 1 : 0, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.outlineUniforms.uniforms;\n        this.uniforms.uAngleStep = OutlineFilter.getAngleStep(quality);\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uThickness[0] = this.thickness / input.source.width;\n        this.uniforms.uThickness[1] = this.thickness / input.source.height;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the angleStep by quality\n     * @param quality\n     */\n    private static getAngleStep(quality: number): number\n    {\n        return parseFloat(((Math.PI * 2) / Math.max(\n            quality * OutlineFilter.MAX_SAMPLES,\n            OutlineFilter.MIN_SAMPLES,\n        )).toFixed(7));\n    }\n\n    /**\n     * The thickness of the outline\n     * @default 1\n     */\n    get thickness(): number { return this._thickness; }\n    set thickness(value: number) { this._thickness = this.padding = value; }\n\n    /**\n     * The color value of the ambient color\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n     * The quality of the outline from `0` to `1`.\n     * Using a higher quality setting will result in more accuracy but slower performance\n     * @default 0.1\n     */\n    get quality(): number { return this._quality; }\n    set quality(value: number)\n    {\n        this._quality = value;\n        this.uniforms.uAngleStep = OutlineFilter.getAngleStep(value);\n    }\n\n    /**\n     * Whether to only render outline, not the contents.\n     * @default false\n     */\n    get knockout(): boolean { return this.uniforms.uKnockout === 1; }\n    set knockout(value: boolean) { this.uniforms.uKnockout = value ? 1 : 0; }\n}\n","import { Filter, GlProgram, GpuProgram, Point } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './pixelate.frag';\nimport source from './pixelate.wgsl';\n\ntype Size = number | number[] | Point;\n\n/**\n * This filter applies a pixelate effect making display objects appear 'blocky'.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/pixelate.png)\n *\n * @class\n * @extends Filter\n */\nexport class PixelateFilter extends Filter\n{\n    /**\n     * @param {Point|Array<number>|number} [size=10] - Either the width/height of the size of the pixels, or square size\n     */\n    constructor(size: Size = 10)\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'pixelate-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                pixelateUniforms: {\n                    uSize: { value: new Float32Array(2), type: 'vec2<f32>' },\n                },\n            },\n        });\n\n        this.size = size;\n    }\n\n    /**\n     * The size of the pixels\n     * @default [10,10]\n     */\n    get size(): Size { return this.resources.pixelateUniforms.uniforms.uSize; }\n    set size(value: Size)\n    {\n        if (value instanceof Point)\n        {\n            this.sizeX = value.x;\n            this.sizeY = value.y;\n        }\n        else if (Array.isArray(value))\n        {\n            this.resources.pixelateUniforms.uniforms.uSize = value;\n        }\n        else\n        {\n            this.sizeX = this.sizeY = value;\n        }\n    }\n\n    /**\n    * The size of the pixels on the `x` axis\n    * @default 10\n    */\n    get sizeX(): number { return this.resources.pixelateUniforms.uniforms.uSize[0]; }\n    set sizeX(value: number) { this.resources.pixelateUniforms.uniforms.uSize[0] = value; }\n\n    /**\n    * The size of the pixels on the `y` axis\n    * @default 10\n    */\n    get sizeY(): number { return this.resources.pixelateUniforms.uniforms.uSize[1]; }\n    set sizeY(value: number) { this.resources.pixelateUniforms.uniforms.uSize[1] = value; }\n}\n","import { deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './radial-blur.frag';\nimport source from './radial-blur.wgsl';\n\nimport type { PointData } from 'pixi.js';\n\n/** Options for the RadialBlurFilter constructor. */\nexport interface RadialBlurFilterOptions\n{\n    /**\n     * Sets the angle of the motion for blur effect\n     * @default 0\n     */\n    angle?: number;\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[];\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 3\n     * @default 5\n     */\n    kernelSize?: number;\n    /**\n     * The maximum size of the blur radius, less than `0` equates to infinity\n     * @default -1\n     */\n    radius?: number\n}\n\n/**\n * The RadialBlurFilter applies a Motion blur to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/radial-blur.png)\n *\n * @class\n * @extends Filter\n */\nexport class RadialBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: RadialBlurFilterOptions = {\n        angle: 0,\n        center: { x: 0, y: 0 },\n        kernelSize: 5,\n        radius: -1,\n    };\n\n    public uniforms: {\n        uRadian: number;\n        uCenter: PointData;\n        uKernelSize: number;\n        uRadius: number;\n    };\n\n    private _angle!: number;\n    private _kernelSize!: number;\n\n    /**\n     * @param options - Options for the RadialBlurFilter constructor.\n     */\n    constructor(options?: RadialBlurFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [angle=0] - Sets the angle of the motion for blur effect.\n     * @param {PIXI.Point|number[]} [center=[0,0]] - The center of the radial.\n     * @param {number} [kernelSize=5] - The kernelSize of the blur filter. Must be odd number >= 3\n     * @param {number} [radius=-1] - The maximum size of the blur radius, `-1` is infinite\n     */\n    constructor(angle?: number, center?: PointData | number[], kernelSize?: number, radius?: number);\n    /** @ignore */\n    constructor(...args: [RadialBlurFilterOptions?] | [number?, (PointData | number[])?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }');\n\n            options = { angle: options };\n\n            if (args[1])\n            {\n                const x = 'x' in args[1] ? args[1].x : args[1][0];\n                const y = 'y' in args[1] ? args[1].y : args[1][1];\n\n                options.center = { x, y };\n            }\n            if (args[2]) options.kernelSize = args[2];\n            if (args[3]) options.radius = args[3];\n        }\n\n        options = { ...RadialBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'radial-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                radialBlurUniforms: {\n                    uRadian: { value: 0, type: 'f32' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uKernelSize: { value: options.kernelSize, type: 'i32' },\n                    uRadius: { value: options.radius, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.radialBlurUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    private _updateKernelSize()\n    {\n        this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;\n    }\n\n    /**\n     * Sets the angle in degrees of the motion for blur effect.\n     * @default 0\n     */\n    get angle(): number { return this._angle; }\n    set angle(value: number)\n    {\n        this._angle = value;\n        this.uniforms.uRadian = value * Math.PI / 180;\n        this._updateKernelSize();\n    }\n\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.center.x; }\n    set centerX(value: number) { this.center.x = value; }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get centerY(): number { return this.center.y; }\n    set centerY(value: number) { this.center.y = value; }\n\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 3\n     * @default 5\n     */\n    get kernelSize(): number { return this._kernelSize; }\n    set kernelSize(value: number)\n    {\n        this._kernelSize = value;\n        this._updateKernelSize();\n    }\n\n    /**\n     * The maximum size of the blur radius, less than `0` equates to infinity\n     * @default -1\n     */\n    get radius(): number { return this.uniforms.uRadius; }\n    set radius(value: number) { this.uniforms.uRadius = value < 0 || value === Infinity ? -1 : value; }\n}\n","import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './reflection.frag';\nimport source from './reflection.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** [MIN, MAX] */\ntype Range = [number, number] | Float32Array;\n\n/** Options for the ReflectionFilter constructor. */\nexport interface ReflectionFilterOptions\n{\n    /**\n     * `true` to reflect the image, `false` for waves-only\n     * @default true\n     */\n    mirror?: boolean;\n    /**\n     * Vertical position of the reflection point, `0.5` equates to the middle\n     * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection\n     * @default 0.5\n     */\n    boundary?: number;\n    /**\n     * Starting and ending amplitude of waves\n     * @default [0,20]\n     */\n    amplitude?: Range;\n    /**\n     * Starting and ending length of waves\n     * @default [30,100]\n     */\n    waveLength?: Range;\n    /**\n     * Starting and ending alpha values\n     * @default [1,1]\n     */\n    alpha?: Range;\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    time?: number;\n}\n\n/**\n * Applies a reflection effect to simulate the reflection on water with waves.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/reflection.png)\n *\n * @class\n * @extends Filter\n */\nexport class ReflectionFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ReflectionFilterOptions = {\n        mirror: true,\n        boundary: 0.5,\n        amplitude: [0, 20],\n        waveLength: [30, 100],\n        alpha: [1, 1],\n        time: 0,\n    };\n\n    public uniforms: {\n        uMirror: number;\n        uBoundary: number;\n        uAmplitude: Float32Array;\n        uWavelength: Float32Array;\n        uAlpha: Float32Array;\n        uTime: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    public time = 0;\n\n    /**\n     * @param options - Options for the ReflectionFilter constructor.\n     */\n    constructor(options?: ReflectionFilterOptions)\n    {\n        options = { ...ReflectionFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'reflection-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                reflectionUniforms: {\n                    uMirror: { value: options.mirror ? 1 : 0, type: 'f32' },\n                    uBoundary: { value: options.boundary, type: 'f32' },\n                    uAmplitude: { value: options.amplitude, type: 'vec2<f32>' },\n                    uWavelength: { value: options.waveLength, type: 'vec2<f32>' },\n                    uAlpha: { value: options.alpha, type: 'vec2<f32>' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.reflectionUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        this.uniforms.uTime = this.time;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * `true` to reflect the image, `false` for waves-only\n     * @default true\n     */\n    get mirror(): boolean { return this.uniforms.uMirror > 0.5; }\n    set mirror(value: boolean) { this.uniforms.uMirror = value ? 1 : 0; }\n\n    /**\n     * Vertical position of the reflection point, default is 50% (middle)\n     * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.\n     * @default 0.5\n     */\n    get boundary(): number { return this.uniforms.uBoundary